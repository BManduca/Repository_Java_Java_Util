Java Polimorfismo: Entenda herança e interfaces.

Aula 06 - Capítulo 01

sem a questão da herança, foi identificado alguns problemas em trabalhar com todas as funcionalidades em uma 
única classe.

nesse projeto, temos diferentes tipos de funcionários, cada um com usas especificações, ou seja, 
termos cada uma delas em um só lugar tornará o programa muito díficil de manter.



se pararmos para analisar, o gerente também é um funcionário, desta forma, 
para o código em si, ficar menos verboso e mais clean, podemos 
inidcar ao Java que o Gerente irá herdar tudo de Funcionário

Na sintaxe do Java, a herança é expressada pela palavra extends...

Ex: public class Gerente extends Funcionario {
		
	}

	
Como Gerente é um Funcionário, podemos utilizar, de forma direta, o método setNome - que origina da 
classe Funcionario. O mesmo vale para Cpf e Salario.


public class TesteGerente {
	
	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("02589645726");
		g1.setSalario(5500.00);
		
		
		System.out.println(g1.getNome());
		System.out.println(g1.getCpf());
		System.out.println(g1.getSalario());
		
		boolean autenticou = g1.autentica(2222);
		
		/*
			o método autenticou foi criado 
			ao executar esse codigo pela primeira vez, resultará em false...
			pois, a senha padrão do Gerente é 0, já que não inicializamos este atributo com nenhum valor
			em particular.
			 
		*/
		System.out.println(autenticou);
		
				
	}
	
}


O gerente conta também com um método autentica, que é particular e não consta em Funcionário....
esse método foi criado na classe Gerente

Inicialmente o valor booelan volsa false, pois,  o padrão do Gerente é 0, já que inicializamos 
este atributo com nenhum valor em particular.


para efetuar um teste, foi criado um método setSanha() na classe Gerente..

ao retornar a classe TesteGerente, chamando o método setSenha()...

é possível observar que no próprio menu do Eclipse surge algumas sugestões, 
que enquanto todos os outros otiginam de Funcionario, este método
vem da classe Gerente.


Nessa aula começamos a falar sobre a herança e aprendemos:

-> quais problemas a herança pode resolver
-> como usar herança no Java através de palavra chave extends
-> ao herdar, a classe filha ganha todas as características (atributos) e todas as funcionalidades (métodos) da classe mãe
-> conhecemos o primeiro benefício da herança: Reutilização do código




Aula 01 - Capítulo 02 - Herança no diagrama de classes

Somente relembrando, foi criada uma classe extra, para respresentar o gerente. Nela, temos todo o código específico para representá-lo, 
ou seja, uma senha, que é atribuído a mais em relação ao Funcionário, e dois métodos, sem contar com o Bonificação, que ganhará especificação, 
em relação ao que já existe para o Funcionário.


Para não repetirmos código, utilizamos conceitos de herança, representado pela palavra extends:

public class Gerente extends Funcionario {
	
	//codigo omitido
	
}


com o trecho de código acima, estamos querendo dizer que o Gerente possui os mesmos atributos e métodos que o Funcionario.


É costume chamar esta classe Funcionario de classe mãe ou classe pai ou simplesmente, que ela está acima de outra com a qual estivermos 
trabalhando.

no caso, a classe Gerente seria a classe filha.

 

agora com toda essa parte de nomenclatura...

Vamos criar o primeiro gerente

Gerente g1 = new Gerente();

O que acontece interiormente, é a criação de um objeto, com atributos baseados na hierarquia estabelecida.



Representando objeto Gerente

nome = null

cpf = null

salario = 0.0

senha = 0



Ou seja, se pararmos para entender, todos os atributos de Funcionario, mais o seu especifico, que é a senha, foram apresentados.
É esta a ideia de herança.

Ao utilizar a referencia g1, é possível chamarmos todos os métodos da hierarquia, ou seja, não só aquelas definidas na própria 
classe Gerente, como também aqueles presentes na classe Funcionario.

Ex.:

g1.setNome("Brunno");

o método setNome, so funciona, pois, existe um atributo nome, que por 'de baixo dos panos'... 

ficara assim:


Representando objeto Gerente

nome = Brunno

cpf = null

salario = 0.0

senha = 0




Aula 02 - Capítulo 02 - Reescrita de métodos


so relembrando o objetivo de getBonificacao(), era implementarmos na classe Funcionario, um método que calculasse uma 
bonificação de modo padrão para todos os funcionários, entretanto, foi verificado que não condiz com a realidade de negócio da empresa, 
uma vez que o gerente terá uma bonificação diferenciada dos demais funcionários da empresa.


porém, se olharmos dentro da classe Funcionario, veremos que ao tentar acessar o atributoi salario, não será possivel,
pois, o mesmo é private, onde, este termo é um modificador de visibilidade, que permite que esta informação seja vísivel somente dentro
da classe em si.

Acontece que ao utilizar o método getBonificacao() na classe Gerente estamos querendo acessá-lá externamente, por isso o
erro de compilação apareceu.

uma possível solução, seria trocar este modificador de private para public, porém, isso não seria uma boa prática de 
programação.

Para solucionar essa questão, veremos que há outro modificador que está entre o private e o public, ou seja, ele nem é visivel
somente em determinada classe, e tampouco pode ser visualizado por todos. Este modificador se chama protected.


Desta forma, as informações ali contidas serão públicas apenas para si e para os filhos, as demais classes, não. 

public class Funcionario {

	private String nome;
	private String cpf;
	protected double salario;

	//codigo omitido

}

se caso fazer tanto teste para somente funcionario e tambem para o gerente, ambos a bonificação passará
a funcionar, através da ajuda do terceiro modificador de visibilidades que passamos a utilizar, no caso, o protected, 
que fica entre o private e o public, ainda não foi possivel visualizar , isto de forma clara poque nossas classes
ainda não estão bem subdivididas, por enquanto, elas estão armazenadas em um único pacote.

 o protected foi feito para liberar o acesso ao atributo para os filhos, e deixar privado para todas as outras classes. Ou seja, quem não é um Funcionário
 não verá o salário.
 
 
 
 Olhando outro ponto agora, como programador, ao utilizarmos o this., no caso, do this.salario, no código, somos levados a olhar para os 
 atributos, pois, pensamentos que o atributo salario, automaticamente pertence a esta classe.
 
 o this, além de guardar a referência para mexermos nos atributos do objeto, para desenvolvedor, significa que o atributo deve estar definido
 nesta classe. Entretanto, neste caso o salario não esta definido na classe Gerente, e sim na classe mão ou super classe, Funcionario.
 
 para mostrarmos que o atributo salario, vem da super classe, há outra palavra reservada que pode ser utilizada, que é a super:
 
 public double getBonificacao() {
 	return super.salario;
 }


sendo assim, o desenvolvedor, saberá que é preciso subir na hierarquia para encontrar este atributo,k já que ele 
não está definido nesta classe. 
Se colocarmos super em algo definido dentro da própria classe, o Eclipse apontará um erro de compilação, ja que neste caso
ele procurará na classe acima e não encontrará o atributo.

porém, na classe Funcionário, temos nosso método getBonificação() que é público, devolve um double, e não recebe parâmetros:

//código omitido

public double getBonificacao() {
	return this.salario * 0.1;
}

//codigo omitido


Está prática, é chamado de assinatura de método. Se olharmos para a classe Gerente, veremos que lá temos a mesma assinatura do método, 
o que chamamos de reescrita.


Já entramos mais a fundo na herança. Aprendemos:

 - que classe mãe é chamada de super ou base class
 - que a classe filha também é chamada de sub class
 - como aumentar a visibilidade de um membro (atributo, método) através do protected
 - como acessar ou chamar um membro (atributo, método) através do super
 - como redefinir um método através da sobrescrita



Aula 01 - Capítulo 03 - Reescrita de métodos


Até este ponto, podemos ver uma importante parte do conceito de herança, que tratou da reutilização de código. 
Como uma boa prática de programação, não queremos repetir código e para isso, podemos estender a classe, utilizando 
extends -> Gerente estende a classe Funcionario

Isso significa também dizer que Gerente herdou todos os atributos e características da classe Funcionário.

para exemplificar, a próxima parte, criaremos uma nova classe:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
	
	}

}


desta forma, podemos chamar qualquer um cod métodos definidos, como o setNome() e podemos recuperar
o nome com g1.getNome();



public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}

ao executar, funcionará normalmente, imprimindo o nome do Gerente.

Até o momento, quando criamos um novo objeto, utilizamos o lado direito com o new, para então chamarmos o construtor
com o nome da classe, por exemplo, no caso acima, nem Gerente().
Enquanto isso, no lado esquerdo temos o tipo da variável, seguido pelo nome, no caso Gerente g1.

Entretanto, como todo Gerente é também um funcionário, é possível declarar a variável de um tipo mais genérico,
ou seja, do tipo Funcionario:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Funcionario g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}


Agora a variável é to tipo Funcionario, ela não é mais do tipo Gerente, e sim do tipo mais genérico.Nosso código continua compilando e se executarmos
novamente, teremos o mesmo resultado...

será que o contrário tambem funciona?
Resposta: Não!!!

pois todo Gerente é um funcionário, mas nem todo funcionário é um Gerente.


se colocarmos ao contrario: 

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Funcioario(); //criação de um novo gerente.
		
		//codigo omitido
		
		g1.autentica(2222);
		
		
	}

}



O compilador vai indicar que isso não funciona, mas porque? 
Se criamos um objeto do tipo Gerente?
Para o compilador, isso não importa. 

O que ele faz é analisar o tipo da referência, ou seja, g1 que é do tipo Funcionario.

Como esta classe não tem o método autentica, o compilador indica a presença de um erro.

O que pode variar, é o tipo da referência, "aquilo" que está localizado à esquerda do nome do objeto, no caso
é o Funcionario,mas como vimos, poderíamos ter definido como Gerente também, que funcionária.

A isso, damos o nome de polimorfismo, temos um mesmo objeto do tipo Gerente, mas há duas formas possíveis de chegarmos 
a este objeto, dois tipos diferentes de referência. 



Aula 02 - Capítulo 03 - Aplicando polimorfismo

anteriormente falavamos sobre o polimorfismo, onde vimos que se trata de um objeto que pode ser referenciado por uma referência do mesmo tipo, ou genérica.
Ou seja, se temos um objeto Gerente(), a referência pode ser tanto do tipo Gerente, quanto do tipo Funcionario.


para fazer o controle de bonificação, teremos uma classe chamada ControleBonificacao. Ela terá um método público chamado registra:

public class ControleBonificacao {

        public void registra() {

        }
}



nesta classe queremos tambem retornar a soma de todas as bonificações, por isso criaremos um método chamado getTotal():

public class ControleBonificacao {

        public void registra() {

        }
        
        public double getTotal() {
        	return total;
        }
}


retornamos na classe TesteReferencia e imprimimos o total:

public class TesteReferencias {

        public static void main(String[] args) {

                Gerente g1 = new Gerente();
                g1.setNome("Brunno");
                g1.setSalario(3000.0);

                ControleBonificacao controle = new ControleBonificacao();
                controle.registra(g1);

                System.out.println("Bonificação Geral: " + controle.getTotal());

        }
}


ao executar, ira aparecer somente o total, indicando que funcionou. Como temos somente um gerente, 
so aparecerá a bonificação do Gerente.



em seguida se quisermos criar mais um funcionario, do tipo Funcionario, com salário de R$2000,00 e que também será registrado e
tambem mais um funcionario, sue será o Editor de video, ele tambem estende a classe Funcionario e sua bonificação é o 
valor padrão acrescido de  R$100,00

so criarmos a classe: 

public class EditorVideo extends Funcionario {

        public double getBonificacao() {
                return super.getBonificacao() + 100;

        }
}


Para que possamos registralos, não será preciso criar outro metodo dentro da classe ControleBonoficacao, pois, 
queremos ter apenas um método que sirva para os funcionários de forma geral:


public class ControleBonificacao {

	private double total;
	
	public void registra(Funcionario f) {
		double boni = f.getBonificacao();
		this.total = this.total + boni;
	}

	public double getTotal() {
		return total;
	}
	
}


Aula 06 - Capítulo 03 - Resumo herança

 

Existem duas características principais da herança:
 - reutilização de código
 - Polimorfismo
 
 
 
 Reutilização de código, é conceituada como extensão da classe, com a palavra extends, isso faz com que a classe filha 
 herde automaticamente todos os dados, atributos e funcionalidades dos métodos
 
 no meu código, a Gerente é baseada em todos os atributos da hierarquia.
 
 quando criamos um gerente, ele terá uma senha, porque isso está definido dentro da classe Gerente. Além disso, 
 ele também terá um nome, um cpf e um salário, todos estes são atributos da classe Funcionario. O mesmo vale para os métodos, 
 como getters e setters e getBonificacao(), incluindo os métodos específicos de Gerente que terão preferência em relação
 aos mais genéricos.
 
 ja o Polimorfismo é mais complexo
 Por exemplo a hierarquia da classe Funcionario, em que ela é mão das classes Gerente e EditorVideo.
 
 Quando criamos um Gerente, temos um objeto do tipo Gerente:
 
 Gerente gerente = new Gerente();
 
 o objeto em si nunca muda o tipo. Uma vez que ele é criado com o tipo Gerente, terá sempre este tipo. O mesmo vale para o EditorVideo:
 
 EditorVideo ev = new EditorVideo();
 
 no caso acima, o tipo será sempre EditorVideo. O que pode variar somente é o tipo da referência -> Isto é polimorfismo!
 
 antes o tipo da referência era sempre igual ao tipo do objeto, com o polimorfismo, aprendemos que a referência pode ser de um 
 tipo mais genérico. No nosso exemplo, esta classe mais genérica é Funcionario:
 
 Funcionario gerente = new Gerente();
 Funcionario editor = new EditorVideo();
 
 isso so funciona, porque todo Gerente e EditorVideo são Funcionários...
 
 
 Ao termos uma referência genérica, do tipo Funcionário, que aponta para objetos de tipos diferentes. É possível comunicar com os 
 tipos diferentes de objetos, apartir de uma mesma referência genérica. Daí surge a vantagem do polimorfismo, como a seguir:
 
 
 public class ControleBonificacao {
 	private double soma;
 	
 	public void registra(Funcionario f){
 		double boni = f.getBonificacao();
 		this.soma = this.soma + boni;
 	}
 	
 	public double getSoma() {
 		return soma;
 	}
 	
 }
 
 
 a referência genérica, neste caso Funcionario, pode apontar para tipos de objetos diferentes, desde que pertençam à mesma 
 hierarquia. Pode apontar tanto para um Gerente, quanto para um EditorVideo, ou ainda para um Funcionario.
 
 Por isso, não temos como saber, somente apartir desta classe, qual objeto getBonificacao() será chamado. 
 Para o Gerente há um método especifico para o cálculo da bonificação, e por ser especifico, é ele quem 
 será chamado, isso tambem se aplica parar EditorVideo.
 
 Criando um novo tipo de Funcionario ou seja, uma nova classe.
 
 public class Designer extends Funcionario {
 	
 	public double getBonificacao(){
 		System.out.println("Chamando metodo de Bonoificação do Designer");
 		return 200;
 	}
 	
 }
 
 
 Lembrando que Designer também é um funcionário:
 
 
 
 
public class TesteReferencias {

	public static void main(String[] args) {
		
		//codigo omitido
		
		Designer d = new Designer();
		d.setNome("Gabriela");
		d.setSalario(3200.0);
		
		ControleBonificacao controle = new ControleBonificacao();
		
		System.out.println("Nome: " + g1.getNome());
		System.out.println("Salario: " + g1.getSalario());
		System.out.println("Bonificacao: " + g1.getBonificacao());
		controle.registra(g1);
		System.out.println();
		System.out.println("Nome: " + f.getNome());
		System.out.println("Salario: " + f.getSalario());
		System.out.println("Bonificacao: " + f.getBonificacao());
		controle.registra(f);
		System.out.println();
		System.out.println("Nome: " + ev.getNome());
		System.out.println("Salario: " + ev.getSalario());
		System.out.println("Bonificacao: " + ev.getBonificacao());
		controle.registra(ev);
		System.out.println();
		System.out.println("Nome: " + d.getNome());
		System.out.println("Salario: " + d.getSalario());
		System.out.println("Bonificacao: " + d.getBonificacao());
		controle.registra(d);
		System.out.println();
		System.out.println("Bonificação Geral: " + controle.getTotal());

	}

}
 
 
 
 Até o momento tudo esta compilando e funcionando e não foi necessário alterar o método apenas
 para criarmos um novo tipo de funcionario, essa é a vantagem do polimorfismo - é possível criar
 um código bem mais genérico que depende de um tipo genérico, criar outros tipos em nosso código, 
 e tudo continua funcionando. 
 
 
 Nessa aula aprendemos que:

 - objetos não mudam de tipo;
 - a referência pode mudar, e aí entra o polimorfismo;
 - o polimorfismo permite usar referências mais genéricas para a comunicação com um objeto;
 - o uso de referências mais genéricas permite desacoplar sistemas.
 
 
 
 
 
 
 
 
 
Aula 01 - Capítulo 04 - Herança e construtores

Utilizando o exemplo da classe Conta, com duas filhas agora, a ContaCorrente e a ContaPoupanca, ou seja,
tipos mais especificos de uma conta. 

o objetivo em si, é criar dois tipos mais específicos de contas. Se pensarmos em um banco, temos contas-poupancas
ou conta-corrente.


criando classe ContaCorrente, ja extendendo as informações da classe mãe..

public class ContaCorrente extends Conta {
	
}


estamos falando sobre reutilização de código, porém, da forma como colocamos acima, não irá compilar
qual seria o problema?

Estendendo a Conta os atributos e métodos são herdados, entretanto, os construtores não são herdados.
Os construtores pertencem somente a sua própria classe.

na classe conta, tem seu construtor especifico:

//Código omitido

    public Conta(int agencia, int numero){
        Conta.total++;
        System.out.println("O total de contas é " + Conta.total);
        this.agencia = agencia;
        this.numero = numero;
        this.saldo = 100;
        System.out.println("Estou criando uma conta " + this.numero);
    }

//Código omitido


porém, ela não é automaticamente dísponivel para a classe filha ContaCorrente. 
Por isso, temos que escrever, na classe ContaCorrente, nosso proprio construtor:

public class ContaCorrente extends Conta {
	
	public ContaCorrente() {
		
	}
	
} 


ainda acontece o erro de compilação, pois, como estamos utilizando 
o construtor padrão, ainda esta tentando chamar o construtor padrão
da classe mãe.

para contornarmos essa situação, o que podemos fazer utilizar a palavra reservada
super(), que sempre fará com que o Java busque o padrao, mas podemos utilizá-lo 
para chamar um construtor especifico

na classe ContaCorrente(), definiremos parâmetros para o construtor: 

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero) {
		super(agencia,numero);
	}
	
}


e para a ContaPoupanca, basta repetir o mesmo processo de criação:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia,numero);
	}
	
}




Aula 03 - Capítulo 04 - Conta Corrente e Poupança

Para manipular nossas classes ContaPoupanca e ContaCorrente, 
primeiro iremos criar uma classe para teste:

public class TesteContas {
	
	public static void main(String[] args) {
	
	}
	
}


agora, criando um objeto ContCorrente e um ContaPoupanca:

public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		
	}
	
}


importante notar que o método deposita(), não está pŕesente na classe ContaCorrente e nem na 
ContaPoupanca, estamos reutilizando os métodos da classe Conta.



fazendo mais umn exemplo..
temos a questão de transferir dinheiro, para isso, utilizamos o método transfere():


public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		cc.transfere(10.0, cp); //transferindo 10 reais da cc para a cp
		
		//para imprimir no caso o saldo
		System.out.println("CC: " + cc.getSaldo());
		System.out.println("CP: " + cp.getSaldo());
		
		
	}
	
}

ao observarmos, ganhamos todas as funcionalidades da classe mãe, Conta.

mas aonde eu posso obervar o polimorfismo?

no método transfere, por exemplo:

public class Conta {

//Código omitido

public boolean transfere(double valor, Conta destino) {

    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Restante do código omitido


Estamos recebendo como parâmetro a Conta, ou seja, o tipo genérico, não sabemos ainda se é uma 
ContaCorrente ou ContaPoupanca.
Este código funciona por causa do polimorfismo, temos referência do tipo genérico, que pode 
apontar para qualquer um mais específico, no caso, tanto ContaCorrente, quanto ContaPoupanca.

alterando um pouco a regra de saque da ContaCorrente, onde ao sacar, deve ser cobrado uma taxa de R$0,20. 
Este com portamento é esoecífico da ContaCorrente.

Na classe mãe, Conta, já temos um método saca(), iremos redefinir o comportamento deste método, 
na classe ContaCorrente.


quando se reescreve um modo, em cima do mesmo aparece a palavra reservada, que recebe no caso nome 
de anotação na configuração do código Java. Esta configuração é para o compilador.


agora, queremos fazer a operação de saque e ainda, subtrair R$0,20 referentes a taxa de operação.

criando a variavel do tipo double valorASacar, que recebe o valor a ser sacado mais a taxa.

aproveitando o código criado pelo Eclipse, chamaremos o super, ou seja, subiremos na hierarquia
para chamarmos o método saca da classe Conta, a unica alteração será no vaor, que passará a ser 
valorASacar:


public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
}




no método transfere localizado na classe mãe Conta, quando utilizamos o this.saca, estamos chamando o método
saca com o valor, para destino.deposita temos a mesma coisa,  é feita uma referência, o this é uma referência.

public class Conta {

//Código omitido

public boolean transfere(double valor, conta destino) {
    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Código omitido



Na classe TesteContas, quan do utilizamos o cc.transfere, o this tem o mesmo valor de cc, ou seja, o this é a seta
que aponta para um objeto do tipo ContaCorrente. 

Desta forma, estaremos chamando o método mais específico, ou seja, o da ContaCorrentem por isso, 
ao executarmos a classe TesteContasjá obtivemos o resultado esperado.



Aula 07 - Capítulo 04 - O que aprendemos?

Nessa aula, vimos:

 - Conceitos de herança, construtores e polimorfismo
 - A utilização da anotação @Override
 - Construtores não são herdados
 - Um construtor da classe mãe pode ser chamado através do super()




Aula 01 - Capítulo 05 - Classes Abstratas


Utilizando a classe Funcionario novamente, voltaremos ao projeto
bytebank-herdado, que tem as classes Funcionario e Gerente, seguindo hierarquia que tínhamos, onde 
o Funcionario é a super classe.

os filhos desta classe são Gerente, EditorVIdeo e Designer.

em uma empresa de verdade não existe o cargo Funcionario, porém, não podemos apagar simplesmente 
a classe Funcionario, pois, muita coisa pararia de funcionar, pois o conceito comum
de Funcionario é importante para nosso código, para resolver isso
abriremos a classe Funcionario e queremos evitar de alguma forma a existência de um funcionário 
desta forma, sem nenhum cargo específico. Para que isso aconteça, o new Funcionario() não deveria
funcionar, pois, estaríamos criando algo que é só um funcionário.

No exemplo, "funcionário" é um conceito, algo abstrato, o concreto seria, gerente, programador,
designer, editor de vídeo e por ai vai, note que todos são funcionários, mas não apenas isso.

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//codigo omitido
	
}


A palavra abstract sempre estará relacionado com herança

antes no nossa classe TesteReferencias estavamos fazendo um new Funcionario();
isso gerará um erro de compilação, pois, não é mais possível criar um funcionario. 
o new indica criação de algo concreto, como a classe Funcionario agora 
é abstrata, será indicado como erro de compilação.


podemos simplesmente tirar este trecho de código ou então criar um 
Gerente, Designer, EditorVideo... pois todos são realmente funcionarios.


na classe TesteFuncionario, temos tambem:

import java.text.DecimalFormat;

public class TesteFuncionario {
	
	public static void main(String[] args) {
		
		DecimalFormat formatador = new DecimalFormat("0.00");
		
		//Funcionario brunno = new Funcionario(); -> erro de compilação
		Funcionario brunno = new Gerente();
		
		brunno.setNome("Brunno Manduca");
		brunno.setCpf("083540479-03");
		brunno.setSalario(2500.80);
		
		System.out.println("Nome: " + brunno.getNome());
		System.out.println("CPF: " + brunno.getCpf());
		System.out.println("Salário: " + brunno.getSalario());
		System.out.println("Bonificação: " + formatador.format(brunno.getBonificacao()));
		
	}
	
}


ao trocarmos o tipo de funcionario para gerente, o codigo compila certinho, 
Ou seja, assim temos um filho concreto (Gerente), da classe Funcionario.

O mesmo conceito pode ser aplicado à estrutura de contas, temos uma conta
 poupança e outra corrente, mas não existe um tipo que seja simplesmente "conta".


Aula 03 - Capítulo 05 - Métodos abstratos


aprendemos que não é possível instanciar objetos desta classe Funcionario, pois a mesma é abstrata...

//nao pode instanciar essa classe, pq é abstrata
public abstract class Funcionario {

    private String nome;
    private String cpf;
    private double salario;

	//Código omitido
	
}

Desta forma, evitamos que seja instanciado um funcionário genérico, já que a função não existe na prática.

Os códigos das classes filhas continuam funcionando normalmente, graças ao polimorfismo, podemos fazer 
referências genéricas. Não perdemos os benefícios da herança, apenas eliminamos a possibilidade de criar um 
objeto com uma referência do tipo Funcionario, o que não faz sentido.


Agora, o chefe da empresa, decidiu que não deve existir mais uma regra padrão de bonificação para todos. 
o designer receberá R$200,00, o editor de vídeo receberá R$150,00 e o gerente um salário simples.
Não há mais uma regra padrão.

Como temos um parâmetro específico para cada funcionário, não precisamos mais do método 
getBonificacao() na classe Funcionario, por isso, ficará comentado:




public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//utilizando modificador public, para que o método tenha visibilidade pública
	/*public double getBonificacao() {
		return this.salario * 0.1;
	}*/
	
	//codigo omitido

}


Nenhuma das classes filhas utiliza o método getBonoificacao() da classe mãe, cada uma conta com seu 
próprio método específico..

Abriremos a classe ControleBonificacao:

public class ControleBonificacao {

        private double soma;

        public void registra(Funcionario f) {
            double boni = f.getBonificacao();
            this.soma = this.soma + boni;
        }

        public double getSoma() {
            return soma;
        }
}

 
E temos um problema, porque a classe Funcionario não tem mais o método getBonificacao(), 
e está apontando para um objeto f, do tipo Funcionario() - isso significa que o código não compilará.

Se apontasse para um objeto g, por exemplo, isso não aconteceria pois, na classe Gerente, 
há um método getBonificacao específico.

Ou seja, comentar o método em Funcionario não foi uma boa solução. 
Removeremos as barras para retorná-lo à forma
 

Temos que garantir que este método exista para as classes filhas. Ele precisa existir, para que o 
ControleBonificacao funcione. Entretanto, o ideal seria que ele não tivesse uma implementação, 
ou seja, que existisse da seguinte forma:

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//porém, getBonificacao() é um método concreto e para que isso funcione, declararemos ele como abstrato
	public abstract double getBonificacao();
	
}


Da mesma forma que existem classes bastratas, também existem métodos abstratos.


Na classe, significa que não é possível instanciar objetos desta classe.
No método, significa que ele não tem um corpo, ou seja, 
que não foi implementado.

como solução: O método será implementado somente nas classes filhas.


Ex.:
public class Designer extends Funcionario {

    public double getBonificacao() {
        return 200;
    }
    
}


ao colcoar o método abstrato em uma classe mãe, obrigamos os filhos a implementar 
tal método



mas há algumas outra forma de conseguir compliar esta classe, sem que utilizemos um método abstrato?
Sim, poderíamos implementar um método diretamente na classe filha, ou indicar que a própria classe filha é abstrata.

Sendo assim, aprendemos que abstract é uma palavra-chave que podemos utilizar tanto antes de 
uma classe quanto antes de um método. Apesar de seu significado estar relacionado, ele é diferente da herança.



Aula 07 - Capítulo 05 - Abstract no exemplo Conta


Falando do ponto de vista prático, não deve existir um tipo de objeto que seja somente uma conta, 
ele deve ser ou corrente ou poupança, mas não queremos apagar a classe Conta, pois, 
precisamos de seus atributos e métodos.

Para isso, manteremos esta classe, na forma abstrata.

public abstract class Conta {
	
	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido

}


assim, não será possível instanciar objetos da classe Conta;

Para ilustrar, abriremos a classe TesteContas e ao tentarmos criar um objeto do tipo Conta(), 
veremos que não é possível compilar este código.


Uma classe abstrata, pode sim ter atributos e eles serão herdados pelas classes filhas.
Ela pode sim ter construtores também, pois estes construtores não são herdados automaticamente
ou diretamente, mas podem ser chamados em classes filhas por da palavra reservada super. A classe
abstrata pode sim ter métodos também e os filhos herdam estas funcionalidades.

tudo continua de alguma forma válido, a unica vedação seria o instanciamento de objetos 
do tipo da classe abstrata. 



para praticar nos métodos, utilizaremos abstract no método deposita:

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor) {
		
		this.saldo = this.saldo + valor;
		
	}

}


assim que colocamos o abstract, gera um erro, pois não podemos colocar a classe como abstract
e manter a implementação toda ali.

Isso pode ser resolvido de duas formas:
 - tirando o abstract
 - removendo toda a implementação;
 

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor);

}



Agora as classe filhas serão obrigadas a implementar este método.



Class ContaCorrente:

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


após implementar o deposita, 
acessaremos o saldo, com o super, entretanto, ele não é visível, pois tem um modificador de visibilidade privado.
Podemos alterá-lo para protected, liberando assim o atributo para os filhos.

public abstract class Conta {

	protected double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido
	
}



fazendo o mesmo para a ContaPoupanca:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia, numero);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


Nessa aula aprendemos:

 - O que são classes abstratas
 - Para que servem classes abstratas
 - O que são métodos abstratos
 - Para que servem métodos abstratos


Aula 01 - Capítulo 06 - Mais uma classe abstrata


Revisando: 

temos a hierarquia: A classe mãe é Funcionario e as filhas são 
Gerente, EditorVIdeo e Designer.

A classe mãe é abstrata, enquanto as filhas são todas concretas. Lembrando também que a classe Gerente 
tem um método autentica(), que é do tipo boolean.

Cirando uma nova classe chamada SistemaInterno. Justamente, surgiu esta necessidade, de representarmos 
um sistema interno da empresa, que não é acessível para todos:


public class SistemaInterno {

}


Atenção, este sistema será visualizado por alguns funcionários, por isso, conterá um  método autentica() próprio, que recebe como paramêtro
um Gerente g, como base nisso o método será chamado e a senha será definida em um atributo, acima do método.
Consequentemente, esta senha será passada para o método autentica():


public class SistemaInterno {

		private int senha = 2222;

        public void autentica(Gerente g) {
            g.autentica(senha);
        }
        
}


como o metodo devolve true ou false, por isso, ele será do tipo boolean. 
Se caso autenticar, impriremos uma mensagem "Pode entrar no sistema!!", 
casp contrário, a mensagem "Senha incorreta! Não pode entrar no sistema!" será exibida.


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}



Criando agora um teste para a classe, chamada TesteSistema, 
criando um novo gerente, e o daremos uma senha. Além disso, instituiremos 
um sistema interno, passando o gerente g:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);	
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);

	}

}


Criando  um novo tipo de funcionario, para isso teremos a classe Administrador e cuja super classe será Funcionario:


public class Administrador extends FuncionarioAutenticavel {
	
	
	@Override
	public double getBonificacao() {
		return 50;
	}
	
	

}


Porém, o Administrador também terá uma senha e consequentemente, deverá ter também um método autentica, 
mas este código causará estranheza, pois estará repetindo linhas e também não resolverá o problema. 
Na classe TesteSistema, tentaremos criar um administrador, com uma senha e autenticar o mesmo:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);

	}

}

ao passamors a linha si.autentica(adm), teremos um erro de compilação, isso acontece porque na classe 
SistemaInterno só é aceito o Gerente, ou seja, teríamos que duplicar o método autentica na classe SistemaInterno, 
porém, essa constante repetição de código não é uma boa prática de programação, então deixaremos o código como está 
hoje, sem o método autentica(Administrador adm)


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


Em vez de duplicar, poderíamos inseri-lo na classe mãe Funcionario, 
o problema desta abordagem é que agora, tanto o EditorVideo e o Designer podem entrar no 
SistemaInterno, algo que não poderia acontecer..


A ídeia então é tirar o método autentica() da classe Funcionario, porque ela não se aplica a todos os funcionarios.
para solucionar este caso, teremos uma nova classe, intermediária entre a classe mãe Funcionario e as filhas autenticaveis
Administrador e Gerente.

A nova classe se chamará FuncionarioAutenticavel e as classe Administrador e Gerente estenderão esta classe.
A classe FuncionarioAutenticavel, por sua vez, estenderá a classe Funcionario.

A classe FuncionarioAutenticavel será abstrata e o método autentica() será armazenado, portanto, nessa classe.

Criando a classe FuncionarioAutenticavel e inserimos nela o método autentica():


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}



Agora, como próximo passo, temos que adequar as classes Gerente e Administrador, para estender da classe FuncionarioAutenticavel


Agora sim, as classes atendem a nossa hierarquia.
SistemaIterno ficará assim:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}

E o TesteSistema:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


assim, o código funcionará normalmente, sem necessidade de duplicar o código.





Aula 02 - Capítulo 06 - Herança multipla


O SistemaInterno não depende diretamente do Administrador nem do Gerente. 
A Abstração entre os tipos específicos de funcionários e a classe SistemaInterno é a classe autenticavel. 
Esta é a vantagem, pensando sob a ótica de design.

Criando um novo tipo de funcionário autenticavel, como por exemplo, um diretor, com uma classe Diretor, 
que estenede a classe FuncionarioAutenticavel, ou seja, podemos fazer isso sem alterar o código da classe SistemaInterno, 
nem da FuncionarioAutenticavel. Esta é a grande vantagem. Os dois lados podem evoluir separadamente.

Desde que não haja uma separação na classe FuncionarioAutenticavel, as suas classes filhas não serão afetadas. 
Esta é a vantagem do design desta abstração, do polimorfismo.

Nosso novo desafio é que não basta mais representarmos apenas funcionários em nossos sistemas, teremos que representar
também os clientes.

A classe Cliente também terá acesso ao SistemaInterno, além disso, ela também será autenticável.

o que poderíamos fazer inicialmente, é que a classe Cliente estendesse a classe FuncionarioAutenticavel, porém, 
de cara não parece ser uma boa idéia.

Criando a classe Cliente, estendendo a classe FuncionarioAutenticavel:


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	@Override
	public double getBonificacao() {
		return 0;
	}

}


Já pode se perceber um primeiro problema, pois, faz sentido o Cliente receber uma bonificação?
Pois, ele não é um funcionário, além disso, na hierarquia, esta da seguinte forma:
O cliente é um funcionário autenticável e também um funcionário.


A primeira parte da afirmação já nos soa bem estranho, porque apesar de ter a autenticação, cliente não
é um funcionário. 
Piora, quando subimos na hirerarquia e vemos que não é possível afirmarmos que o clienteé um funcionario.
Ser um funcionario, significa receber uma bonificação.

Exemplificando, criando um objeto Cliente, 

poderíamos também, ter no lado esquerdo, a classe FuncionarioAutenticavel, graça ao polimorfismo...

public class TesteFuncionario {

        public static void main(String[] args) {

        //Cliente cliente = new Cliente();
        //FuncionarioAutenticavel cliente = new Cliente();
        Funcionario cliente = new Cliente();

        //Código omitido
        
}


Isso, acaba soando estranho, pois cliente seria um funcionario ao mesmo tempo, além disso, 
seria aberta a possibilidade de definirmos um salário para o cliente, algo que também não faria sentido.

Desta forma, a classe Cliente poderia chamar métodos que não deveria ou não poderia ter permissão.

o problema ate aqui, é que o Cliente se torna um funcionario, não é muito eficiente.

Ao observar a classe FuncionarioAutenticavel percebemos que ela, na verdade tem relação somente com a 
senha e o método autentica() e não necessariamente com os funcionários, por isso, ela será renomeada
para somente Autenticavel.


Apesar dessa alteração, como não alteramos a hierarquia, o Cliente continua sendo um Funcionario, já 
que a classe Autenticavel estende Funcionario. Precisamos retirar essa relação.

Assim, retiraremos o extends

public abstract class Autenticavel {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}

ao salvar, começará a apontar vários erros em diversas classes

Em Gerente, temos um problema pois não estamos mais estendendo diretamente a classe Funcionario, por isso, 
não temos mais um getSalario.

Para o Administrador temos um erro similar, não é possível sobrescrever o método getBonificacao(), já que deixamos de herdá-lo

sendo assim, resolvemos o problema do Cliente, mas acabamos criando novos problemas.


No entanto, os métodos setNome(), setCpf() e setSalario(), todos deixaram de funcionar, porque agora o Gerente e 
o Administrador não herdam mais Funcionário.


A herança múltipla não funciona no mundo Java, por isso não adianta querer estender duas classes.
A herança múltipla não é utilizada no Java, porque poderia gerar confusão, Imaginemos que a classe Funcionario
tem uma senha e um método setSenha(), como saberemos que Autenticavel possui exatamente isto. 
Se o Gerente estender ambas, qual dos dois prevalece? Para evitar este tipo de problema, no Java, 
não há herança múltipla.


Este problema todo em si, pode ser resolvido utilizando interfaces.

No fim de tudo, o Gerente irá estender somente a classe Funcionario:




Java Polimorfismo: Entenda herança e interfaces.

Aula 06 - Capítulo 01

sem a questão da herança, foi identificado alguns problemas em trabalhar com todas as funcionalidades em uma 
única classe.

nesse projeto, temos diferentes tipos de funcionários, cada um com usas especificações, ou seja, 
termos cada uma delas em um só lugar tornará o programa muito díficil de manter.



se pararmos para analisar, o gerente também é um funcionário, desta forma, 
para o código em si, ficar menos verboso e mais clean, podemos 
inidcar ao Java que o Gerente irá herdar tudo de Funcionário

Na sintaxe do Java, a herança é expressada pela palavra extends...

Ex: public class Gerente extends Funcionario {
		
	}

	
Como Gerente é um Funcionário, podemos utilizar, de forma direta, o método setNome - que origina da 
classe Funcionario. O mesmo vale para Cpf e Salario.


public class TesteGerente {
	
	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("02589645726");
		g1.setSalario(5500.00);
		
		
		System.out.println(g1.getNome());
		System.out.println(g1.getCpf());
		System.out.println(g1.getSalario());
		
		boolean autenticou = g1.autentica(2222);
		
		/*
			o método autenticou foi criado 
			ao executar esse codigo pela primeira vez, resultará em false...
			pois, a senha padrão do Gerente é 0, já que não inicializamos este atributo com nenhum valor
			em particular.
			 
		*/
		System.out.println(autenticou);
		
				
	}
	
}


O gerente conta também com um método autentica, que é particular e não consta em Funcionário....
esse método foi criado na classe Gerente

Inicialmente o valor booelan volsa false, pois,  o padrão do Gerente é 0, já que inicializamos 
este atributo com nenhum valor em particular.


para efetuar um teste, foi criado um método setSanha() na classe Gerente..

ao retornar a classe TesteGerente, chamando o método setSenha()...

é possível observar que no próprio menu do Eclipse surge algumas sugestões, 
que enquanto todos os outros otiginam de Funcionario, este método
vem da classe Gerente.


Nessa aula começamos a falar sobre a herança e aprendemos:

-> quais problemas a herança pode resolver
-> como usar herança no Java através de palavra chave extends
-> ao herdar, a classe filha ganha todas as características (atributos) e todas as funcionalidades (métodos) da classe mãe
-> conhecemos o primeiro benefício da herança: Reutilização do código




Aula 01 - Capítulo 02 - Herança no diagrama de classes

Somente relembrando, foi criada uma classe extra, para respresentar o gerente. Nela, temos todo o código específico para representá-lo, 
ou seja, uma senha, que é atribuído a mais em relação ao Funcionário, e dois métodos, sem contar com o Bonificação, que ganhará especificação, 
em relação ao que já existe para o Funcionário.


Para não repetirmos código, utilizamos conceitos de herança, representado pela palavra extends:

public class Gerente extends Funcionario {
	
	//codigo omitido
	
}


com o trecho de código acima, estamos querendo dizer que o Gerente possui os mesmos atributos e métodos que o Funcionario.


É costume chamar esta classe Funcionario de classe mãe ou classe pai ou simplesmente, que ela está acima de outra com a qual estivermos 
trabalhando.

no caso, a classe Gerente seria a classe filha.

 

agora com toda essa parte de nomenclatura...

Vamos criar o primeiro gerente

Gerente g1 = new Gerente();

O que acontece interiormente, é a criação de um objeto, com atributos baseados na hierarquia estabelecida.



Representando objeto Gerente

nome = null

cpf = null

salario = 0.0

senha = 0



Ou seja, se pararmos para entender, todos os atributos de Funcionario, mais o seu especifico, que é a senha, foram apresentados.
É esta a ideia de herança.

Ao utilizar a referencia g1, é possível chamarmos todos os métodos da hierarquia, ou seja, não só aquelas definidas na própria 
classe Gerente, como também aqueles presentes na classe Funcionario.

Ex.:

g1.setNome("Brunno");

o método setNome, so funciona, pois, existe um atributo nome, que por 'de baixo dos panos'... 

ficara assim:


Representando objeto Gerente

nome = Brunno

cpf = null

salario = 0.0

senha = 0




Aula 02 - Capítulo 02 - Reescrita de métodos


so relembrando o objetivo de getBonificacao(), era implementarmos na classe Funcionario, um método que calculasse uma 
bonificação de modo padrão para todos os funcionários, entretanto, foi verificado que não condiz com a realidade de negócio da empresa, 
uma vez que o gerente terá uma bonificação diferenciada dos demais funcionários da empresa.


porém, se olharmos dentro da classe Funcionario, veremos que ao tentar acessar o atributoi salario, não será possivel,
pois, o mesmo é private, onde, este termo é um modificador de visibilidade, que permite que esta informação seja vísivel somente dentro
da classe em si.

Acontece que ao utilizar o método getBonificacao() na classe Gerente estamos querendo acessá-lá externamente, por isso o
erro de compilação apareceu.

uma possível solução, seria trocar este modificador de private para public, porém, isso não seria uma boa prática de 
programação.

Para solucionar essa questão, veremos que há outro modificador que está entre o private e o public, ou seja, ele nem é visivel
somente em determinada classe, e tampouco pode ser visualizado por todos. Este modificador se chama protected.


Desta forma, as informações ali contidas serão públicas apenas para si e para os filhos, as demais classes, não. 

public class Funcionario {

	private String nome;
	private String cpf;
	protected double salario;

	//codigo omitido

}

se caso fazer tanto teste para somente funcionario e tambem para o gerente, ambos a bonificação passará
a funcionar, através da ajuda do terceiro modificador de visibilidades que passamos a utilizar, no caso, o protected, 
que fica entre o private e o public, ainda não foi possivel visualizar , isto de forma clara poque nossas classes
ainda não estão bem subdivididas, por enquanto, elas estão armazenadas em um único pacote.

 o protected foi feito para liberar o acesso ao atributo para os filhos, e deixar privado para todas as outras classes. Ou seja, quem não é um Funcionário
 não verá o salário.
 
 
 
 Olhando outro ponto agora, como programador, ao utilizarmos o this., no caso, do this.salario, no código, somos levados a olhar para os 
 atributos, pois, pensamentos que o atributo salario, automaticamente pertence a esta classe.
 
 o this, além de guardar a referência para mexermos nos atributos do objeto, para desenvolvedor, significa que o atributo deve estar definido
 nesta classe. Entretanto, neste caso o salario não esta definido na classe Gerente, e sim na classe mão ou super classe, Funcionario.
 
 para mostrarmos que o atributo salario, vem da super classe, há outra palavra reservada que pode ser utilizada, que é a super:
 
 public double getBonificacao() {
 	return super.salario;
 }


sendo assim, o desenvolvedor, saberá que é preciso subir na hierarquia para encontrar este atributo,k já que ele 
não está definido nesta classe. 
Se colocarmos super em algo definido dentro da própria classe, o Eclipse apontará um erro de compilação, ja que neste caso
ele procurará na classe acima e não encontrará o atributo.

porém, na classe Funcionário, temos nosso método getBonificação() que é público, devolve um double, e não recebe parâmetros:

//código omitido

public double getBonificacao() {
	return this.salario * 0.1;
}

//codigo omitido


Está prática, é chamado de assinatura de método. Se olharmos para a classe Gerente, veremos que lá temos a mesma assinatura do método, 
o que chamamos de reescrita.


Já entramos mais a fundo na herança. Aprendemos:

 - que classe mãe é chamada de super ou base class
 - que a classe filha também é chamada de sub class
 - como aumentar a visibilidade de um membro (atributo, método) através do protected
 - como acessar ou chamar um membro (atributo, método) através do super
 - como redefinir um método através da sobrescrita



Aula 01 - Capítulo 03 - Reescrita de métodos


Até este ponto, podemos ver uma importante parte do conceito de herança, que tratou da reutilização de código. 
Como uma boa prática de programação, não queremos repetir código e para isso, podemos estender a classe, utilizando 
extends -> Gerente estende a classe Funcionario

Isso significa também dizer que Gerente herdou todos os atributos e características da classe Funcionário.

para exemplificar, a próxima parte, criaremos uma nova classe:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
	
	}

}


desta forma, podemos chamar qualquer um cod métodos definidos, como o setNome() e podemos recuperar
o nome com g1.getNome();



public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}

ao executar, funcionará normalmente, imprimindo o nome do Gerente.

Até o momento, quando criamos um novo objeto, utilizamos o lado direito com o new, para então chamarmos o construtor
com o nome da classe, por exemplo, no caso acima, nem Gerente().
Enquanto isso, no lado esquerdo temos o tipo da variável, seguido pelo nome, no caso Gerente g1.

Entretanto, como todo Gerente é também um funcionário, é possível declarar a variável de um tipo mais genérico,
ou seja, do tipo Funcionario:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Funcionario g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}


Agora a variável é to tipo Funcionario, ela não é mais do tipo Gerente, e sim do tipo mais genérico.Nosso código continua compilando e se executarmos
novamente, teremos o mesmo resultado...

será que o contrário tambem funciona?
Resposta: Não!!!

pois todo Gerente é um funcionário, mas nem todo funcionário é um Gerente.


se colocarmos ao contrario: 

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Funcioario(); //criação de um novo gerente.
		
		//codigo omitido
		
		g1.autentica(2222);
		
		
	}

}



O compilador vai indicar que isso não funciona, mas porque? 
Se criamos um objeto do tipo Gerente?
Para o compilador, isso não importa. 

O que ele faz é analisar o tipo da referência, ou seja, g1 que é do tipo Funcionario.

Como esta classe não tem o método autentica, o compilador indica a presença de um erro.

O que pode variar, é o tipo da referência, "aquilo" que está localizado à esquerda do nome do objeto, no caso
é o Funcionario,mas como vimos, poderíamos ter definido como Gerente também, que funcionária.

A isso, damos o nome de polimorfismo, temos um mesmo objeto do tipo Gerente, mas há duas formas possíveis de chegarmos 
a este objeto, dois tipos diferentes de referência. 



Aula 02 - Capítulo 03 - Aplicando polimorfismo

anteriormente falavamos sobre o polimorfismo, onde vimos que se trata de um objeto que pode ser referenciado por uma referência do mesmo tipo, ou genérica.
Ou seja, se temos um objeto Gerente(), a referência pode ser tanto do tipo Gerente, quanto do tipo Funcionario.


para fazer o controle de bonificação, teremos uma classe chamada ControleBonificacao. Ela terá um método público chamado registra:

public class ControleBonificacao {

        public void registra() {

        }
}



nesta classe queremos tambem retornar a soma de todas as bonificações, por isso criaremos um método chamado getTotal():

public class ControleBonificacao {

        public void registra() {

        }
        
        public double getTotal() {
        	return total;
        }
}


retornamos na classe TesteReferencia e imprimimos o total:

public class TesteReferencias {

        public static void main(String[] args) {

                Gerente g1 = new Gerente();
                g1.setNome("Brunno");
                g1.setSalario(3000.0);

                ControleBonificacao controle = new ControleBonificacao();
                controle.registra(g1);

                System.out.println("Bonificação Geral: " + controle.getTotal());

        }
}


ao executar, ira aparecer somente o total, indicando que funcionou. Como temos somente um gerente, 
so aparecerá a bonificação do Gerente.



em seguida se quisermos criar mais um funcionario, do tipo Funcionario, com salário de R$2000,00 e que também será registrado e
tambem mais um funcionario, sue será o Editor de video, ele tambem estende a classe Funcionario e sua bonificação é o 
valor padrão acrescido de  R$100,00

so criarmos a classe: 

public class EditorVideo extends Funcionario {

        public double getBonificacao() {
                return super.getBonificacao() + 100;

        }
}


Para que possamos registralos, não será preciso criar outro metodo dentro da classe ControleBonoficacao, pois, 
queremos ter apenas um método que sirva para os funcionários de forma geral:


public class ControleBonificacao {

	private double total;
	
	public void registra(Funcionario f) {
		double boni = f.getBonificacao();
		this.total = this.total + boni;
	}

	public double getTotal() {
		return total;
	}
	
}


Aula 06 - Capítulo 03 - Resumo herança

 

Existem duas características principais da herança:
 - reutilização de código
 - Polimorfismo
 
 
 
 Reutilização de código, é conceituada como extensão da classe, com a palavra extends, isso faz com que a classe filha 
 herde automaticamente todos os dados, atributos e funcionalidades dos métodos
 
 no meu código, a Gerente é baseada em todos os atributos da hierarquia.
 
 quando criamos um gerente, ele terá uma senha, porque isso está definido dentro da classe Gerente. Além disso, 
 ele também terá um nome, um cpf e um salário, todos estes são atributos da classe Funcionario. O mesmo vale para os métodos, 
 como getters e setters e getBonificacao(), incluindo os métodos específicos de Gerente que terão preferência em relação
 aos mais genéricos.
 
 ja o Polimorfismo é mais complexo
 Por exemplo a hierarquia da classe Funcionario, em que ela é mão das classes Gerente e EditorVideo.
 
 Quando criamos um Gerente, temos um objeto do tipo Gerente:
 
 Gerente gerente = new Gerente();
 
 o objeto em si nunca muda o tipo. Uma vez que ele é criado com o tipo Gerente, terá sempre este tipo. O mesmo vale para o EditorVideo:
 
 EditorVideo ev = new EditorVideo();
 
 no caso acima, o tipo será sempre EditorVideo. O que pode variar somente é o tipo da referência -> Isto é polimorfismo!
 
 antes o tipo da referência era sempre igual ao tipo do objeto, com o polimorfismo, aprendemos que a referência pode ser de um 
 tipo mais genérico. No nosso exemplo, esta classe mais genérica é Funcionario:
 
 Funcionario gerente = new Gerente();
 Funcionario editor = new EditorVideo();
 
 isso so funciona, porque todo Gerente e EditorVideo são Funcionários...
 
 
 Ao termos uma referência genérica, do tipo Funcionário, que aponta para objetos de tipos diferentes. É possível comunicar com os 
 tipos diferentes de objetos, apartir de uma mesma referência genérica. Daí surge a vantagem do polimorfismo, como a seguir:
 
 
 public class ControleBonificacao {
 	private double soma;
 	
 	public void registra(Funcionario f){
 		double boni = f.getBonificacao();
 		this.soma = this.soma + boni;
 	}
 	
 	public double getSoma() {
 		return soma;
 	}
 	
 }
 
 
 a referência genérica, neste caso Funcionario, pode apontar para tipos de objetos diferentes, desde que pertençam à mesma 
 hierarquia. Pode apontar tanto para um Gerente, quanto para um EditorVideo, ou ainda para um Funcionario.
 
 Por isso, não temos como saber, somente apartir desta classe, qual objeto getBonificacao() será chamado. 
 Para o Gerente há um método especifico para o cálculo da bonificação, e por ser especifico, é ele quem 
 será chamado, isso tambem se aplica parar EditorVideo.
 
 Criando um novo tipo de Funcionario ou seja, uma nova classe.
 
 public class Designer extends Funcionario {
 	
 	public double getBonificacao(){
 		System.out.println("Chamando metodo de Bonoificação do Designer");
 		return 200;
 	}
 	
 }
 
 
 Lembrando que Designer também é um funcionário:
 
 
 
 
public class TesteReferencias {

	public static void main(String[] args) {
		
		//codigo omitido
		
		Designer d = new Designer();
		d.setNome("Gabriela");
		d.setSalario(3200.0);
		
		ControleBonificacao controle = new ControleBonificacao();
		
		System.out.println("Nome: " + g1.getNome());
		System.out.println("Salario: " + g1.getSalario());
		System.out.println("Bonificacao: " + g1.getBonificacao());
		controle.registra(g1);
		System.out.println();
		System.out.println("Nome: " + f.getNome());
		System.out.println("Salario: " + f.getSalario());
		System.out.println("Bonificacao: " + f.getBonificacao());
		controle.registra(f);
		System.out.println();
		System.out.println("Nome: " + ev.getNome());
		System.out.println("Salario: " + ev.getSalario());
		System.out.println("Bonificacao: " + ev.getBonificacao());
		controle.registra(ev);
		System.out.println();
		System.out.println("Nome: " + d.getNome());
		System.out.println("Salario: " + d.getSalario());
		System.out.println("Bonificacao: " + d.getBonificacao());
		controle.registra(d);
		System.out.println();
		System.out.println("Bonificação Geral: " + controle.getTotal());

	}

}
 
 
 
 Até o momento tudo esta compilando e funcionando e não foi necessário alterar o método apenas
 para criarmos um novo tipo de funcionario, essa é a vantagem do polimorfismo - é possível criar
 um código bem mais genérico que depende de um tipo genérico, criar outros tipos em nosso código, 
 e tudo continua funcionando. 
 
 
 Nessa aula aprendemos que:

 - objetos não mudam de tipo;
 - a referência pode mudar, e aí entra o polimorfismo;
 - o polimorfismo permite usar referências mais genéricas para a comunicação com um objeto;
 - o uso de referências mais genéricas permite desacoplar sistemas.
 
 
 
 
 
 
 
 
 
Aula 01 - Capítulo 04 - Herança e construtores

Utilizando o exemplo da classe Conta, com duas filhas agora, a ContaCorrente e a ContaPoupanca, ou seja,
tipos mais especificos de uma conta. 

o objetivo em si, é criar dois tipos mais específicos de contas. Se pensarmos em um banco, temos contas-poupancas
ou conta-corrente.


criando classe ContaCorrente, ja extendendo as informações da classe mãe..

public class ContaCorrente extends Conta {
	
}


estamos falando sobre reutilização de código, porém, da forma como colocamos acima, não irá compilar
qual seria o problema?

Estendendo a Conta os atributos e métodos são herdados, entretanto, os construtores não são herdados.
Os construtores pertencem somente a sua própria classe.

na classe conta, tem seu construtor especifico:

//Código omitido

    public Conta(int agencia, int numero){
        Conta.total++;
        System.out.println("O total de contas é " + Conta.total);
        this.agencia = agencia;
        this.numero = numero;
        this.saldo = 100;
        System.out.println("Estou criando uma conta " + this.numero);
    }

//Código omitido


porém, ela não é automaticamente dísponivel para a classe filha ContaCorrente. 
Por isso, temos que escrever, na classe ContaCorrente, nosso proprio construtor:

public class ContaCorrente extends Conta {
	
	public ContaCorrente() {
		
	}
	
} 


ainda acontece o erro de compilação, pois, como estamos utilizando 
o construtor padrão, ainda esta tentando chamar o construtor padrão
da classe mãe.

para contornarmos essa situação, o que podemos fazer utilizar a palavra reservada
super(), que sempre fará com que o Java busque o padrao, mas podemos utilizá-lo 
para chamar um construtor especifico

na classe ContaCorrente(), definiremos parâmetros para o construtor: 

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero) {
		super(agencia,numero);
	}
	
}


e para a ContaPoupanca, basta repetir o mesmo processo de criação:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia,numero);
	}
	
}




Aula 03 - Capítulo 04 - Conta Corrente e Poupança

Para manipular nossas classes ContaPoupanca e ContaCorrente, 
primeiro iremos criar uma classe para teste:

public class TesteContas {
	
	public static void main(String[] args) {
	
	}
	
}


agora, criando um objeto ContCorrente e um ContaPoupanca:

public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		
	}
	
}


importante notar que o método deposita(), não está pŕesente na classe ContaCorrente e nem na 
ContaPoupanca, estamos reutilizando os métodos da classe Conta.



fazendo mais umn exemplo..
temos a questão de transferir dinheiro, para isso, utilizamos o método transfere():


public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		cc.transfere(10.0, cp); //transferindo 10 reais da cc para a cp
		
		//para imprimir no caso o saldo
		System.out.println("CC: " + cc.getSaldo());
		System.out.println("CP: " + cp.getSaldo());
		
		
	}
	
}

ao observarmos, ganhamos todas as funcionalidades da classe mãe, Conta.

mas aonde eu posso obervar o polimorfismo?

no método transfere, por exemplo:

public class Conta {

//Código omitido

public boolean transfere(double valor, Conta destino) {

    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Restante do código omitido


Estamos recebendo como parâmetro a Conta, ou seja, o tipo genérico, não sabemos ainda se é uma 
ContaCorrente ou ContaPoupanca.
Este código funciona por causa do polimorfismo, temos referência do tipo genérico, que pode 
apontar para qualquer um mais específico, no caso, tanto ContaCorrente, quanto ContaPoupanca.

alterando um pouco a regra de saque da ContaCorrente, onde ao sacar, deve ser cobrado uma taxa de R$0,20. 
Este com portamento é esoecífico da ContaCorrente.

Na classe mãe, Conta, já temos um método saca(), iremos redefinir o comportamento deste método, 
na classe ContaCorrente.


quando se reescreve um modo, em cima do mesmo aparece a palavra reservada, que recebe no caso nome 
de anotação na configuração do código Java. Esta configuração é para o compilador.


agora, queremos fazer a operação de saque e ainda, subtrair R$0,20 referentes a taxa de operação.

criando a variavel do tipo double valorASacar, que recebe o valor a ser sacado mais a taxa.

aproveitando o código criado pelo Eclipse, chamaremos o super, ou seja, subiremos na hierarquia
para chamarmos o método saca da classe Conta, a unica alteração será no vaor, que passará a ser 
valorASacar:


public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
}




no método transfere localizado na classe mãe Conta, quando utilizamos o this.saca, estamos chamando o método
saca com o valor, para destino.deposita temos a mesma coisa,  é feita uma referência, o this é uma referência.

public class Conta {

//Código omitido

public boolean transfere(double valor, conta destino) {
    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Código omitido



Na classe TesteContas, quan do utilizamos o cc.transfere, o this tem o mesmo valor de cc, ou seja, o this é a seta
que aponta para um objeto do tipo ContaCorrente. 

Desta forma, estaremos chamando o método mais específico, ou seja, o da ContaCorrentem por isso, 
ao executarmos a classe TesteContasjá obtivemos o resultado esperado.



Aula 07 - Capítulo 04 - O que aprendemos?

Nessa aula, vimos:

 - Conceitos de herança, construtores e polimorfismo
 - A utilização da anotação @Override
 - Construtores não são herdados
 - Um construtor da classe mãe pode ser chamado através do super()




Aula 01 - Capítulo 05 - Classes Abstratas


Utilizando a classe Funcionario novamente, voltaremos ao projeto
bytebank-herdado, que tem as classes Funcionario e Gerente, seguindo hierarquia que tínhamos, onde 
o Funcionario é a super classe.

os filhos desta classe são Gerente, EditorVIdeo e Designer.

em uma empresa de verdade não existe o cargo Funcionario, porém, não podemos apagar simplesmente 
a classe Funcionario, pois, muita coisa pararia de funcionar, pois o conceito comum
de Funcionario é importante para nosso código, para resolver isso
abriremos a classe Funcionario e queremos evitar de alguma forma a existência de um funcionário 
desta forma, sem nenhum cargo específico. Para que isso aconteça, o new Funcionario() não deveria
funcionar, pois, estaríamos criando algo que é só um funcionário.

No exemplo, "funcionário" é um conceito, algo abstrato, o concreto seria, gerente, programador,
designer, editor de vídeo e por ai vai, note que todos são funcionários, mas não apenas isso.

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//codigo omitido
	
}


A palavra abstract sempre estará relacionado com herança

antes no nossa classe TesteReferencias estavamos fazendo um new Funcionario();
isso gerará um erro de compilação, pois, não é mais possível criar um funcionario. 
o new indica criação de algo concreto, como a classe Funcionario agora 
é abstrata, será indicado como erro de compilação.


podemos simplesmente tirar este trecho de código ou então criar um 
Gerente, Designer, EditorVideo... pois todos são realmente funcionarios.


na classe TesteFuncionario, temos tambem:

import java.text.DecimalFormat;

public class TesteFuncionario {
	
	public static void main(String[] args) {
		
		DecimalFormat formatador = new DecimalFormat("0.00");
		
		//Funcionario brunno = new Funcionario(); -> erro de compilação
		Funcionario brunno = new Gerente();
		
		brunno.setNome("Brunno Manduca");
		brunno.setCpf("083540479-03");
		brunno.setSalario(2500.80);
		
		System.out.println("Nome: " + brunno.getNome());
		System.out.println("CPF: " + brunno.getCpf());
		System.out.println("Salário: " + brunno.getSalario());
		System.out.println("Bonificação: " + formatador.format(brunno.getBonificacao()));
		
	}
	
}


ao trocarmos o tipo de funcionario para gerente, o codigo compila certinho, 
Ou seja, assim temos um filho concreto (Gerente), da classe Funcionario.

O mesmo conceito pode ser aplicado à estrutura de contas, temos uma conta
 poupança e outra corrente, mas não existe um tipo que seja simplesmente "conta".


Aula 03 - Capítulo 05 - Métodos abstratos


aprendemos que não é possível instanciar objetos desta classe Funcionario, pois a mesma é abstrata...

//nao pode instanciar essa classe, pq é abstrata
public abstract class Funcionario {

    private String nome;
    private String cpf;
    private double salario;

	//Código omitido
	
}

Desta forma, evitamos que seja instanciado um funcionário genérico, já que a função não existe na prática.

Os códigos das classes filhas continuam funcionando normalmente, graças ao polimorfismo, podemos fazer 
referências genéricas. Não perdemos os benefícios da herança, apenas eliminamos a possibilidade de criar um 
objeto com uma referência do tipo Funcionario, o que não faz sentido.


Agora, o chefe da empresa, decidiu que não deve existir mais uma regra padrão de bonificação para todos. 
o designer receberá R$200,00, o editor de vídeo receberá R$150,00 e o gerente um salário simples.
Não há mais uma regra padrão.

Como temos um parâmetro específico para cada funcionário, não precisamos mais do método 
getBonificacao() na classe Funcionario, por isso, ficará comentado:




public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//utilizando modificador public, para que o método tenha visibilidade pública
	/*public double getBonificacao() {
		return this.salario * 0.1;
	}*/
	
	//codigo omitido

}


Nenhuma das classes filhas utiliza o método getBonoificacao() da classe mãe, cada uma conta com seu 
próprio método específico..

Abriremos a classe ControleBonificacao:

public class ControleBonificacao {

        private double soma;

        public void registra(Funcionario f) {
            double boni = f.getBonificacao();
            this.soma = this.soma + boni;
        }

        public double getSoma() {
            return soma;
        }
}

 
E temos um problema, porque a classe Funcionario não tem mais o método getBonificacao(), 
e está apontando para um objeto f, do tipo Funcionario() - isso significa que o código não compilará.

Se apontasse para um objeto g, por exemplo, isso não aconteceria pois, na classe Gerente, 
há um método getBonificacao específico.

Ou seja, comentar o método em Funcionario não foi uma boa solução. 
Removeremos as barras para retorná-lo à forma
 

Temos que garantir que este método exista para as classes filhas. Ele precisa existir, para que o 
ControleBonificacao funcione. Entretanto, o ideal seria que ele não tivesse uma implementação, 
ou seja, que existisse da seguinte forma:

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//porém, getBonificacao() é um método concreto e para que isso funcione, declararemos ele como abstrato
	public abstract double getBonificacao();
	
}


Da mesma forma que existem classes bastratas, também existem métodos abstratos.


Na classe, significa que não é possível instanciar objetos desta classe.
No método, significa que ele não tem um corpo, ou seja, 
que não foi implementado.

como solução: O método será implementado somente nas classes filhas.


Ex.:
public class Designer extends Funcionario {

    public double getBonificacao() {
        return 200;
    }
    
}


ao colcoar o método abstrato em uma classe mãe, obrigamos os filhos a implementar 
tal método



mas há algumas outra forma de conseguir compliar esta classe, sem que utilizemos um método abstrato?
Sim, poderíamos implementar um método diretamente na classe filha, ou indicar que a própria classe filha é abstrata.

Sendo assim, aprendemos que abstract é uma palavra-chave que podemos utilizar tanto antes de 
uma classe quanto antes de um método. Apesar de seu significado estar relacionado, ele é diferente da herança.



Aula 07 - Capítulo 05 - Abstract no exemplo Conta


Falando do ponto de vista prático, não deve existir um tipo de objeto que seja somente uma conta, 
ele deve ser ou corrente ou poupança, mas não queremos apagar a classe Conta, pois, 
precisamos de seus atributos e métodos.

Para isso, manteremos esta classe, na forma abstrata.

public abstract class Conta {
	
	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido

}


assim, não será possível instanciar objetos da classe Conta;

Para ilustrar, abriremos a classe TesteContas e ao tentarmos criar um objeto do tipo Conta(), 
veremos que não é possível compilar este código.


Uma classe abstrata, pode sim ter atributos e eles serão herdados pelas classes filhas.
Ela pode sim ter construtores também, pois estes construtores não são herdados automaticamente
ou diretamente, mas podem ser chamados em classes filhas por da palavra reservada super. A classe
abstrata pode sim ter métodos também e os filhos herdam estas funcionalidades.

tudo continua de alguma forma válido, a unica vedação seria o instanciamento de objetos 
do tipo da classe abstrata. 



para praticar nos métodos, utilizaremos abstract no método deposita:

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor) {
		
		this.saldo = this.saldo + valor;
		
	}

}


assim que colocamos o abstract, gera um erro, pois não podemos colocar a classe como abstract
e manter a implementação toda ali.

Isso pode ser resolvido de duas formas:
 - tirando o abstract
 - removendo toda a implementação;
 

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor);

}



Agora as classe filhas serão obrigadas a implementar este método.



Class ContaCorrente:

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


após implementar o deposita, 
acessaremos o saldo, com o super, entretanto, ele não é visível, pois tem um modificador de visibilidade privado.
Podemos alterá-lo para protected, liberando assim o atributo para os filhos.

public abstract class Conta {

	protected double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido
	
}



fazendo o mesmo para a ContaPoupanca:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia, numero);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


Nessa aula aprendemos:

 - O que são classes abstratas
 - Para que servem classes abstratas
 - O que são métodos abstratos
 - Para que servem métodos abstratos


Aula 01 - Capítulo 06 - Mais uma classe abstrata


Revisando: 

temos a hierarquia: A classe mãe é Funcionario e as filhas são 
Gerente, EditorVIdeo e Designer.

A classe mãe é abstrata, enquanto as filhas são todas concretas. Lembrando também que a classe Gerente 
tem um método autentica(), que é do tipo boolean.

Cirando uma nova classe chamada SistemaInterno. Justamente, surgiu esta necessidade, de representarmos 
um sistema interno da empresa, que não é acessível para todos:


public class SistemaInterno {

}


Atenção, este sistema será visualizado por alguns funcionários, por isso, conterá um  método autentica() próprio, que recebe como paramêtro
um Gerente g, como base nisso o método será chamado e a senha será definida em um atributo, acima do método.
Consequentemente, esta senha será passada para o método autentica():


public class SistemaInterno {

		private int senha = 2222;

        public void autentica(Gerente g) {
            g.autentica(senha);
        }
        
}


como o metodo devolve true ou false, por isso, ele será do tipo boolean. 
Se caso autenticar, impriremos uma mensagem "Pode entrar no sistema!!", 
casp contrário, a mensagem "Senha incorreta! Não pode entrar no sistema!" será exibida.


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}



Criando agora um teste para a classe, chamada TesteSistema, 
criando um novo gerente, e o daremos uma senha. Além disso, instituiremos 
um sistema interno, passando o gerente g:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);	
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);

	}

}


Criando  um novo tipo de funcionario, para isso teremos a classe Administrador e cuja super classe será Funcionario:


public class Administrador extends FuncionarioAutenticavel {
	
	
	@Override
	public double getBonificacao() {
		return 50;
	}
	
	

}


Porém, o Administrador também terá uma senha e consequentemente, deverá ter também um método autentica, 
mas este código causará estranheza, pois estará repetindo linhas e também não resolverá o problema. 
Na classe TesteSistema, tentaremos criar um administrador, com uma senha e autenticar o mesmo:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);

	}

}

ao passamors a linha si.autentica(adm), teremos um erro de compilação, isso acontece porque na classe 
SistemaInterno só é aceito o Gerente, ou seja, teríamos que duplicar o método autentica na classe SistemaInterno, 
porém, essa constante repetição de código não é uma boa prática de programação, então deixaremos o código como está 
hoje, sem o método autentica(Administrador adm)


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


Em vez de duplicar, poderíamos inseri-lo na classe mãe Funcionario, 
o problema desta abordagem é que agora, tanto o EditorVideo e o Designer podem entrar no 
SistemaInterno, algo que não poderia acontecer..


A ídeia então é tirar o método autentica() da classe Funcionario, porque ela não se aplica a todos os funcionarios.
para solucionar este caso, teremos uma nova classe, intermediária entre a classe mãe Funcionario e as filhas autenticaveis
Administrador e Gerente.

A nova classe se chamará FuncionarioAutenticavel e as classe Administrador e Gerente estenderão esta classe.
A classe FuncionarioAutenticavel, por sua vez, estenderá a classe Funcionario.

A classe FuncionarioAutenticavel será abstrata e o método autentica() será armazenado, portanto, nessa classe.

Criando a classe FuncionarioAutenticavel e inserimos nela o método autentica():


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}



Agora, como próximo passo, temos que adequar as classes Gerente e Administrador, para estender da classe FuncionarioAutenticavel


Agora sim, as classes atendem a nossa hierarquia.
SistemaIterno ficará assim:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}

E o TesteSistema:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


assim, o código funcionará normalmente, sem necessidade de duplicar o código.





Aula 02 - Capítulo 06 - Herança multipla


O SistemaInterno não depende diretamente do Administrador nem do Gerente. 
A Abstração entre os tipos específicos de funcionários e a classe SistemaInterno é a classe autenticavel. 
Esta é a vantagem, pensando sob a ótica de design.

Criando um novo tipo de funcionário autenticavel, como por exemplo, um diretor, com uma classe Diretor, 
que estenede a classe FuncionarioAutenticavel, ou seja, podemos fazer isso sem alterar o código da classe SistemaInterno, 
nem da FuncionarioAutenticavel. Esta é a grande vantagem. Os dois lados podem evoluir separadamente.

Desde que não haja uma separação na classe FuncionarioAutenticavel, as suas classes filhas não serão afetadas. 
Esta é a vantagem do design desta abstração, do polimorfismo.

Nosso novo desafio é que não basta mais representarmos apenas funcionários em nossos sistemas, teremos que representar
também os clientes.

A classe Cliente também terá acesso ao SistemaInterno, além disso, ela também será autenticável.

o que poderíamos fazer inicialmente, é que a classe Cliente estendesse a classe FuncionarioAutenticavel, porém, 
de cara não parece ser uma boa idéia.

Criando a classe Cliente, estendendo a classe FuncionarioAutenticavel:


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	@Override
	public double getBonificacao() {
		return 0;
	}

}


Já pode se perceber um primeiro problema, pois, faz sentido o Cliente receber uma bonificação?
Pois, ele não é um funcionário, além disso, na hierarquia, esta da seguinte forma:
O cliente é um funcionário autenticável e também um funcionário.


A primeira parte da afirmação já nos soa bem estranho, porque apesar de ter a autenticação, cliente não
é um funcionário. 
Piora, quando subimos na hirerarquia e vemos que não é possível afirmarmos que o clienteé um funcionario.
Ser um funcionario, significa receber uma bonificação.

Exemplificando, criando um objeto Cliente, 

poderíamos também, ter no lado esquerdo, a classe FuncionarioAutenticavel, graça ao polimorfismo...

public class TesteFuncionario {

        public static void main(String[] args) {

        //Cliente cliente = new Cliente();
        //FuncionarioAutenticavel cliente = new Cliente();
        Funcionario cliente = new Cliente();

        //Código omitido
        
}


Isso, acaba soando estranho, pois cliente seria um funcionario ao mesmo tempo, além disso, 
seria aberta a possibilidade de definirmos um salário para o cliente, algo que também não faria sentido.

Desta forma, a classe Cliente poderia chamar métodos que não deveria ou não poderia ter permissão.

o problema ate aqui, é que o Cliente se torna um funcionario, não é muito eficiente.

Ao observar a classe FuncionarioAutenticavel percebemos que ela, na verdade tem relação somente com a 
senha e o método autentica() e não necessariamente com os funcionários, por isso, ela será renomeada
para somente Autenticavel.


Apesar dessa alteração, como não alteramos a hierarquia, o Cliente continua sendo um Funcionario, já 
que a classe Autenticavel estende Funcionario. Precisamos retirar essa relação.

Assim, retiraremos o extends

public abstract class Autenticavel {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}

ao salvar, começará a apontar vários erros em diversas classes

Em Gerente, temos um problema pois não estamos mais estendendo diretamente a classe Funcionario, por isso, 
não temos mais um getSalario.

Para o Administrador temos um erro similar, não é possível sobrescrever o método getBonificacao(), já que deixamos de herdá-lo

sendo assim, resolvemos o problema do Cliente, mas acabamos criando novos problemas.


No entanto, os métodos setNome(), setCpf() e setSalario(), todos deixaram de funcionar, porque agora o Gerente e 
o Administrador não herdam mais Funcionário.


A herança múltipla não funciona no mundo Java, por isso não adianta querer estender duas classes.
A herança múltipla não é utilizada no Java, porque poderia gerar confusão, Imaginemos que a classe Funcionario
tem uma senha e um método setSenha(), como saberemos que Autenticavel possui exatamente isto. 
Se o Gerente estender ambas, qual dos dois prevalece? Para evitar este tipo de problema, no Java, 
não há herança múltipla.



public class Gerente extends Funcionario{
	
	//codigo omitido

}

o mesmo caso, para o administrador:

public class Administrador extends Funcionario{
	
	//codigo omitido

}



dentro da classe TesteGerente, deixaremos as linhas de código referentes ao 
método autentica() comentado. 


public class TesteGerente {

	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("05446985236");
		g1.setSalario(5000.00);
		
		
		/*g1.setSenha(2222);
		boolean autenticou = g1.autentica(2222);*/
		
		System.out.println("Nome " + g1.getNome());
		System.out.println("CPF: " + g1.getCpf());
		System.out.println("Salário: " + g1.getSalario());
		System.out.println("Bonificação: " + g1.getBonificacao());
		/*System.out.println(autenticou);*/

	}

}




Na classe TesteSistema, também há vários erros, pois, agora Gerente não pode acessar o SistemaInterno. 
Por enquanto comentaremos as seguintes linhas de código:



public class TesteSistema {

	public static void main(String[] args) {
		
		/*Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);*/

	}

}


agora o código está funcionando, mas para isso foi preciso remover a relação 
entre Gerente e a classe Autenticavel e ele voltou a estender a classe Funcionario, o mesmo
foi feito com o Administrador.



Aula 03 - Capítulo 06 - A primeira interface


O Objetivo agora é que as três classes: Cliente, administrador e Gerente consigam acessar o SistemaInterno, considerando 
que apenas o Administrador e o Gerente são funcionários e herdam Funcionario

Buscaremos estabelecer algum tipo de relacionamento entre a classe Gerente e a Autenticavel, que não poderá ser herança, 
já que não é possível que o gerente estenda duas classes ao mesmo tempo (Herança múltipla), esta outra relação se chama interface.

De ínicio, precisaremos transformar a classe Autenticavel em uma interface, que é uma classe Abstrata, com todos os métodos 
abstratos. Dentro de uma interface, não ha nada concreto.

A classe Autenticavel tem vários atributos, porém, como ela se tornará uma classe abstrata, não pode ter implementação, 
sendo assim, ela ficará da seguinte forma:


public abstract class Autenticavel {
	
	public abstract void setSenha(int senha);
	
	
	public abstract boolean autentica(int senha);

}

Em outras palavras, eliminamos da classe, tudo que era concreto, mantivemos apenas a assinatura dos métodos.
Agora transformaremos ela em uma interface.

ao trocarmos o valor class por interface:

public abstract interface Autenticavel {
	
	public abstract void setSenha(int senha);
	
	
	public abstract boolean autentica(int senha);

}



Para colocar em prática essa alteração e verificarmos seu funcionamento, na classe Cliente, 
vemos que ela já apresenta um erro de compilação, na maneira que ela se encontra hoje, pois 
estamos utilizando a referência extends:

public class Cliente extends Autenticavel {

}

O extends existe somente para quando teremos que herdar algo de outra classe, 
mas com a interface, estamos "assinando um contrato", ou seja, estamos implementando, 
por isso, utilizamos o implements e agora gerando os métodos concretos, so efetuar a implementação que tinhamos 
antes aqui:


public class Cliente implements Autenticavel {
	
	private int senha;

	@Override
	public void setSenha(int senha) {
		this.senha = senha;
	}

	@Override
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}


Desta forma, obrigamos o Cliente a ter uma senha e um método Autentica. 
Quem for Autenticavel, deverá implementar estes métodos.


E assim, repetiremos o mesmo processo para Administrador e Gerente, ambos estão conectados à 
interface por uma seta pontilhada, indicando que ambos também "assinam o contrato" Autenticavel.

Ao passo em que só é possível fazer com que uma classe herde apenas uma outra classe, podemos fazer com que sejam 
"assinados" tantos "contratos" forem necessários, ou seja, não há limite para o número de implementações.


Aula 05 - Capítulo 06 - Completando o sistema


Inicialmente criamos a interface Autenticavel e o Cliente já a implementou, 
precisamos agora implementar no Administrador e no Gerente..

abrindo a classe Gerente:

public class Gerente extends Funcionario implements Autenticavel {

        public double getBonificacao() {
                return super.getSalario();
        }
}


Automaticamente, após criar e implementar Autenticavel, a classe Gerente se obriga
a implementar os métodos da interface, ou seja, setSenha e autentica.. ela ficará assim:

public class Gerente extends Funcionario implements Autenticavel {

        private int senha;

        public double getBonificacao() {
                System.out.println("Chamando o método de bonificacao do GERENTE");
                return super.getSalario();
        }

        @Override
        public void setSenha(int senha) {
            this.senha = senha;
        }

        @Override
        public boolean autentica(int senha) {
            if(this.senha == senha) {
                return true;
            } else {
                return false;
            }
        }
}


Em outras palavras, a classe Gerente é um Funcionário, herda da classe Funcionario, assina o contrato
Autenticavel e é um Autenticavel.


É possivel colocar mais de uma interface, pois não é que nem herança, que so existe no JAVA a simples.
Isso porque, como nesta modalidade não há nada concreto, não corremos o o risco de acontecer uma duplicidade 
de métodos, a implementação acontecerá na própria classe, evitando assim qualquer confusão.


Mesma aplicação, para o administrador:

public class Administrador extends Funcionario implements Autenticavel {

        private int senha;

        @Override
        public double getBonificacao() {
                return 50;
        }

        @Override
        public void setSenha(int senha) {
            this.senha = senha;
        }

        @Override
        public boolean autentica(int senha) {
            if(this.senha == senha) {
                return true;
            } else {
                return false;
            }
        }
}

Somente recapitulando:
 - Gerente é um Funcionario e assina Autenticavel;
 - Administrador é Funcionario e assina Autenticavel; 
 - Cliente é Autenticavel;


No SistemaInterno:

public class SistemaInterno {

        private int senha = 2222;

        public void autentica(Autenticavel fa) {

        //Código omitido
        
}

Percebemos que a conexão entre a classe e a Autenticavel continua existindo. Esta é a vantagem de termos uma interface, podemos utiliza-lá 
para definir um tipo

Abrindo a classe TesteGerente:


public class TesteGerente {

	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("05446985236");
		g1.setSalario(5000.00);
		
		
		g1.setSenha(2222);
		boolean autenticou = g1.autentica(2222);
		
		System.out.println("Nome " + g1.getNome());
		System.out.println("CPF: " + g1.getCpf());
		System.out.println("Salário: " + g1.getSalario());
		System.out.println("Bonificação: " + g1.getBonificacao());
		System.out.println(autenticou);

	}

}

Podmeos descomentar o trecho com método getSenha(), pois, o mesmo
volta a funciona, porque agora o Gerente sabe setar a senha e sabe se autenticar.


Na classe TesteSistema, estava com todo o código comentado, podemos desfazer a ação, 
pois, tudo estará funcionando:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		Cliente clt = new Cliente();
		clt.setSenha(5678);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);
		System.out.println();
		System.out.println("Senha do Cliente: ");
		si.autentica(clt);

	}

}


Desta forma, o Gerente continua sendo um Funcionario, o Cliente não é, mas os dois 
são capazes de acessar o mesmo SistemaInterno. Isso acontece porque a interface é absolutamente genérica

todos os tipos de funcionarios, Administrador, Gerente, EditorVideo e Designer, estendem da classe Funcionario.

A interface Autenticavel, por sua vez, é a abstração entre SistemaInterno e todas as pessoas que desejam acessa-lo.
Ainda que as pessoas não tenham relação entre si.



Nessa aula aprendemos que:

 - Não existe herança múltipla em Java.
 - Conceitos de interface.
 - Diferenças entre classes abstratas e interfaces.
 - interfaces são uma alternativa a herança referente ao polimorfismo




Aula 01 - Capítulo 07 - Revendo a composição


Anterioremente, definimos nossa própria interface e como vimos, ela não possui um código concreto.
Não é possível definir um atributo dentro de uma, o código simplesmente não compila. Da mesma forma, 
nenhum método podera ter uma implementação.

Uma Interface só define métodos, as regras destes devem ser definidas nas classes que a implementam.

No caso da interface Autenticavel:


public abstract interface Autenticavel {
	
	public abstract void setSenha(int senha);
	
	
	public abstract boolean autentica(int senha);

}


Todas as classes que a implementarem terão a obrigação de implementar os métodos setSenha() e autentica()


Em comparação com o conceito de herança, onde temos os pilares da reutilização de código e o polimorfismo, quando falamos
de interfaces, não há código concreto, assim, o objetivo não é a reutilização de código, ela é, sim uma alternativa ao polimorfismo.

Solução pura de polimorfismo -> utilizar interface

Mas e se quisermos somente reutilização de código, é recomendado utilizar a herança?
Não, a herança é recomendada quando há a combinação das necessidades de reutilização de código e polimorfismo.

e se a necessidadefor somente a reutilização de código?

anteriormente, podemos perceber que repetimos várias vezes, as linhas de código
referente aos métodos setSenha() e autentica(). 
A idéia é isalar estar linhas de código em uma classe.


Criaremos então a classe Autenticador e incluiremos nesta nova classe
os métodos setSenha() e autentica():


public class Autenticador {
	
	private int senha;
	
	
	public void setSenha(int senha) {
		this.senha = senha;
	}

	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

	
}


agora, não podemos simplesmente apagar estes métodos das outras classes, 
pois isso resultaria na quebra de compromisso com a interface Autenticavel. 
Manteremos a assinatura e eliminaremos a lógica dos métodos.

primeiramente acessamos a classe Cliente e para resolver este problema, 
teremos um atributo Autenticador e criaremos um construtor padrão para, 
dentro dele, teremos uma instância do Autenticador. 

Com isso, eliminamos a necessidade da existência do atributo 
senha, desta forma, quando chamar a senha, quem guardará essa 
informação não será diretamente a própria classe e sim o Autenticador. 
No autenticador, chamaremos o autenticador, desta forma, utilizamos o seu setSenha. Isso significa que 
delegamos a chamada - o método não foi embora, mas a implementação, que era concreta, agpra foi delegada..



public class Cliente implements Autenticavel {
	
	private Autenticador autenticador;
	
	//constructor
	public Cliente() {
		this.autenticador = new Autenticador();
	}

	@Override
	public void setSenha(int senha) {
		this.autenticador.setSenha(senha);
	}

	@Override
	public boolean autentica(int senha) {
		return this.autenticador.autentica(senha);
	}

}


agora aplicando todo esse processo novamente no Administrador:


public class Administrador extends Funcionario implements Autenticavel{
	
	private Autenticador autenticador;
	
	//constructor
	public Administrador() {
		this.autenticador = new Autenticador();
	}
	
	@Override
	public double getBonificacao() {
		return 50;
	}
	
	@Override
	public void setSenha(int senha) {
		this.autenticador.setSenha(senha);
	}

	@Override
	public boolean autentica(int senha) {
		return this.autenticador.autentica(senha);
	}

}


e agora na classe Gerente:

public class Gerente extends Funcionario implements Autenticavel{
	
	private Autenticador autenticador;

	public double getBonificacao() {
		return super.getSalario();
	}


	//constructor
	public Gerente() {
		this.autenticador = new Autenticador();
	}
	
	
	@Override
	public void setSenha(int senha) {
		this.autenticador.setSenha(senha);
	}

	@Override
	public boolean autentica(int senha) {
		return this.autenticador.autentica(senha);
	}


}



Recapitulando:

 - Criamos uma nova classe, Chamada Autenticador
 - As classes Cliente, Administrador e Gerente as utilizam, esse relacionamento se chama de composição;
 
 O relacionamento de composição difere do relacionamento de herança, naquele, há ainda uma interdependência 
 onde a existência de um depende da do outro, já na composição, cada classe existe independentemente.
 
 Isso significa, que quando queremos fazer apenas a reutilização de código, podemos utilizar composição. 
 teoricamente, podemos trablhar sem herança com o Java.
 
 

No fim, temos as duas opções em Java. Atualmente, é mais comum a utilização das interfaces e composições, em 
detrimento da herança, mas é importante sabermos que ambos existem.



Aula 02 - Capítulo 07 - Mais uma interface

A hierarquia está estruturada da seguinte forma: 

A classe Conta é a mãe, e é abstrata, por sua vez, as classes
ContaCorrente e Conta Poupanca a herdam

O objetivo em si é incluir um calculador de imposto, representado pela 
classe CalculadorImposto. 
Uma contacorrente é tributável, enquanto que uma conta poupanca não é.

Além disso, teremos um seguro de vida, representado pela Classe SeguroDeVida, que não herda a classe Conta, 
mas também é tributado e acordo com o CalculadorImposto.

Para que o CalculadorImposto não fique atrelado a nenhum método específico, teremos um intermedíario, 
que será uma interface, chamada Tributavel.

Recapitulando: Uma interface contém somente abstrações, não possui nenhum atributo ou método concreto.

O CalculadorImposto, por usa vez, trabalhará com esta interface Tributavel. As classes SeguroDeVida e ContaCorrente
deverão implementar a interface Tributavel.

A idéia do CalculadorImposto é que ele armazena o valor dos impostos, somando todos os valores.



Aula 03 - Capítulo 07 - Implementando tributaveis

Utilizando o projeto bytebank-herdado-conta, 
iremos criar a Interface Tributavel, que definirá a assinatura do método:

public interface Tributavel {
	
}


não há necessidade de utilizarmos o abstract antes de interface, já que este último já presume 
que tudo que já nele é de fato abstrato. O segundo passo será inserirmos o método getValorImposto() 
na interface:

public interface Tributavel {

	public abstract double getValorImposto();
	
}


por padrão, o método nesse caso será public abstract, por isso é comum que nem se escreva isso no código, 
ele compila normalmente, já que é o padrão da interface.

Em seguida, criaremos o CalculadorDeImposto:

public class CalculadorDeImposto {
	
	
	
}


Nela, teremos um método registra(), que recebe um tributavel:

public class CalculadorDeImposto {
	
	public void registra(Tributavel t){
	
	}	
	
}

Todos que implementaram a interface Tributavel podem ser utilizados, por meio deste método:

Completando o método registra() com o método getValorImposto():

public class CalculadorDeImposto {
	
	public void registra(Tributavel t){
		
		double valor = t.getValorImposto();
			
	}	
	
}

Neste código, não sabemos extatamente o quê deve ser tributável. Pode ser tanto uma Conta Corrente, 
quanto um seguro de vida, por exemplo:

Para somarmos o total de impostos, criaremos um atributo totalImposto:


public class CalculadorDeImposto {
	
	private double totalImposto;
	
	public void registra(Tributavel t){
		
		double valor = t.getValorImposto();
		this.totalImposto += valor;
			
	}	
	
}


por fim teremos um método para nos devolver o valor total de impostos, que é o getTotalImpostos():

public class CalculadorDeImposto {
	
	private double totalImposto;
	
	public void registra(Tributavel t){
	
		double valor = t.getValorImposto();
		this.totalImposto += valor;
		
	}
	
	public double getTotalImposto() {
		return totalImposto;
	}
	
}

Através dessa arquitetura, poderíamos, inclusive, ter desenvolvedores diferentes, desde que ambos tenham definido
a interface Tributavel em comum, as classes podem evoluir sem que nada seja alterado nela.

Agora criaremos a classe para o sefuro de vida, nomeando a mesma de SeguroDeVida. Definiremos a interface Tributavel 
para que ela a implemente, desde o momento de sua criação.


public class SeguroDeVida implements Tributavel {

	@Override
	public double getValorImposto() {
		return 42; //somente um retorno exemplo
	}

}


Além do SeguroDeVida, a classe ContaCorrente também implementa a interface Tributavel. Assim, 
adicionaremos a devida referência:

public class ContaCorrente extends Conta implements Tributavel{
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}
	
}


Mas somente isso não é suficiente, precisamos ainda implementar os métodos, no caso, getValorImposto(), cujo cálculo será
de 1% do valor do saldo:

public class ContaCorrente extends Conta implements Tributavel{
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}
	
	@Override
	public double getValorImposto() {
		return super.saldo * 0.01;
	}
	
}


Para fazer um teste e verificar se está tudo funcionando, criaremos uma nova classe, chamada
TesteTributaveis e criaremos uma conta corrente cc, que terá saldo de 100 reais.
Em seguida, criaremos um seguro de vida, chamado seguro:


public class TesteTributaveis {

	public static void main(String[] args) {

		ContaCorrente cc = new ContaCorrente(222, 333);
		cc.deposita(100.0);
		
		SeguroDeVida seguro = new SeguroDeVida();
		
	}

}



Por fim, teremos um objeto CalculadorImposto() que receberá os objetos baseados na interface Tributavel:


public class TesteTributaveis {

	public static void main(String[] args) {

		ContaCorrente cc = new ContaCorrente(222, 333);
		cc.deposita(100.0);
		
		SeguroDeVida seguro = new SeguroDeVida();
		
		CalculadorDeImposto calc = new CalculadorDeImposto();
		calc.registra(cc);
		calc.registra(seguro);
		
	}

}

Finalmente, para verificarmos se realmente foi chamado, imprimiremos o total de impostos:


public class TesteTributaveis {

	public static void main(String[] args) {

		ContaCorrente cc = new ContaCorrente(222, 333);
		cc.deposita(100.0);
		
		SeguroDeVida seguro = new SeguroDeVida();
		
		CalculadorDeImposto calc = new CalculadorDeImposto();
		calc.registra(cc);
		calc.registra(seguro);
		
		System.out.println(calc.getTotalImposto());
		
	}

}


Nessa aula, aprendemos:

 - Mais a fundo sobre o uso de interfaces
 - Trabalhamos mais a fundo com herança
 - Vimos outras aplicações de heranças e interfaces


Curso de
Java Exceções: Aprenda a criar, lançar e controlar exceções
Capitulo 05 - aula 4

Retornando a este projeto, finalizado no outro curso, onde temos a seguinte
hierarquia:

(ContaCorrente, ContaPoupanca) -> Conta

A classe mãe é a Conta, e as contas que herdam ou estendem da 
classe mãe são as classes filhas ContaCorrente e ContaPoupanca. 
Temos interesse em mexer no método saca(), da classe mãe Conta.

Ou seja, se alterarmos a assinatura de saca() na classe mãe, 
temos que ter cuidado para alterá-lo na classe filha. Não se 
esqueça que a herança é um relacionamento forte, e que mudanças 
na classe mãe afetarão as filhas.


agora vamos refatorar o nosso código. Na classe Conta, não queremos 
mais que o método saca() devolva um boolean. Se funcionar, 
OK! Se não funcionar, jogaremos uma exceção. Primeiro, esse 
método retornará void

public void saca(double valor) {
    if(this.saldo >= valor) {
        this.saldo -= valor;
        return true;
    } else {
        return false;
    }
}

Através dessa simples mudança de tipo de retorno, 
várias partes do código pararam de compilar, inclusive 
no método transfere() que usa o saca(). Para interromper o erro, 
voltaremos como estava, e criaremos a nossa própria exceção.

Criando uma nova classe, que chamaremos de SaldoInsuficienteException e 
para que ela represente uma exceção, é necessário colocá-la na hierarquia, 
utilizando a herança.

public class SaldoInsuficienteException extends RuntimeException {

}


Como já visto anteriormente, criaremos um construtor e passaremos uma 
mensagem como parâmetro. Depois, chamaremos o construtor da classe
mãe e passaremos a mensagem:

public class SaldoInsuficienteException extends RuntimeException{

	private static final long serialVersionUID = 1L;

	public SaldoInsuficienteException(String msg) {
		super(msg);
	}
	
}

Essa é a nossa exceção. Considerando que ela está pronta, podemos 
voltar à classe Conta, que não irá mais devolver boolean, mas sim 
void. Ou seja, não teremos mais retorno.


public void saca(double valor) {
	if (this.saldo < valor) {
		this.saldo -= valor;
	}
}

O trabalho com exceções é feito no início do método. Primeiro, 
testamos se é possível fazer a operação. Se sim, ok. Se não, já 
lançamos a exceção. Por isso, inverteremos a ordem da regra de negócio.

Se o saldo for menor do que valor ou insuficiente, 
teremos um problema. Caso esse não seja a situação, será 
possível sacar:

public void saca(double valor) {
    if(this.saldo < valor) {
        //problema
    }
    this.saldo -= valor;
}

Esse é um cenário muito comum! If no início do método para 
verificar se há problemas. Agora é a hora de jogar a exceção, 
utilizando throw new:

throw new SaldoInsuficienteException("Saldo: " + this.saldo + ", Valor: " + 
valor);

O método saca() já está funcionando! No entanto, temos alguns erros de 
compilação tanto na classe Conta, quanto na classe ContaCorrente. 
Como vimos, o método transfere() usa o saca(), que devolvia um booleano; 
e o retorno era colocado em if. Entretanto, isso podia ser feito porque 
if recebe algo que é booleano. Agora o método saca() não retorna. Portanto, 
essa chamada não funcionará mais.

Por isso, apagaremos if. Se saca() não funcionar, 
será jogado como uma bomba na pilha, sairá abruptamente do método 
e cairá no método transfere(). Se nada resolver essa bomba, 
ela também sairá abruptamente de transfere().


public void transfere(double valor, Conta destino) {
	this.saca(valor);
	destino.deposita(valor);
}


Então, só será possível depositar o dinheiro, se saca() funcionar. 
Caso não funcione, sairá abruptamente desse método. Com isso, 
a classe Conta já estará funcionando!

Agora, daremos uma olhada na ContaCorrente. Nessa classe, 
o compilador verifica se estamos sobrescrevendo o método. Vamos arrumar:

@Override
public void saca(double valor) {
	double valorASacar = valor + 0.2;
	super.saca(valorASacar);
}

Aparentemente, está compilando! Criaremos uma classe de teste TesteSaca. 
Depois, vamos criar a conta e depositar um valor para sacar.

public class TesteSaca {

	public static void main(String[] args) {
		Conta conta = new ContaCorrente(123, 321);
		
		conta.deposita(200.0);
		conta.saca(200.0);
	
		System.out.println("Saldo atual: " + conta.getSaldo());

	}

}

Nos deparamos com uma exceção, ao executar nosso codigo:

Exception in thread "main" SaldoInsuficienteException: Saldo: 200.0, Valor: 200.2
        at Conta.saca(Conta.java:25)
        at ContaCorrente.saca(ContaCorrente.java:13)
        at TesteSaca.main(TesteSaca.java:8)


Essa exceção aconteceu porque o método saca() adiciona um valor, 
e então não tem como sacar. Vamos alterar o valor do saque para 190.0 e 
testar novamente. Console: 

9.8000000000011



Sacando com Checked Exception:

Anteriormente, criamos a nossa própria exceção SaldoInsuficienteException, 
do tipo Unchecked. Ou seja, ela estende a classe RuntimeException e o compilador 
não nos obriga a fazer nenhum tratamento.

Testaremos também a mesma exceção como Checked. Ela estenderá diretamente da classe 
Exception e verá o tratamento.

Repare que, do jeito que a exceção está agora, o compilador não reclama por não ter um 
tratamento, visto que ela é unchecked, mas não tem problema se criarmos um try-catch:

public static void main(String[] args) {
    Conta conta = new ContaCorrente(123, 321);

    conta.deposita(200.0);
    try {
        conta.saca(210.0);
    } catch(SaldoInsuficienteException ex) {
        System.out.println("Ex: " + ex.getMessage());
    }
    System.out.println(conta.getSaldo());
}

sem o tratamento, a saída no console será assim:
 
Exception in thread "main" SaldoInsuficienteException
        at Conta.saca(Conta.java:25)
        at ContaCorrente.saca(ContaCorrente.java:17)
        at TesteSaca.main(TesteSaca.java:8)

E com o tratamento, temos a seguinte saída:

Ex: Saldo: 200.0, Valor: 210.2
200.0

Já que deu erro, no final foi impresso o valor do saldo de 200.0. Agora, 
vamos mudar a classe para o tipo checked.

public class SaldoInsuficienteException extends Exception {

}

Depois que salvarmos essa alteração, aparecerá um problema no método saca(), 
da classe Conta, na qual alguém joga SaldoInsuficienteException. Levando isso em 
consideração, precisamos deixar claro na assinatura do método.

public void saca(double valor) throws SaldoInsuficienteException {
    if(this.saldo < valor) {
        throw new SaldoInsuficienteException("Saldo: " + this.saldo + ", Valor: " + this.valor);
    }
    this.saldo -= valor;
}


Ao salvar, o compilador passa a reclamar no método logo abaixo transfere():

public void transfere(double valor, Conta destino) {
    this.saca(valor);
    destino.deposita(valor);
}


O transfere() chama o saca(), ou seja, se saca() é perigoso, transfere() precisa 
tomar uma atitude. Escolhemos a opção que deixa claro na assinatura do método que 
a exceção pode acontecer.

public void transfere(double valor, Conta destino) throws SaldoInsuficienteException {
    this.saca(valor);
    destino.deposita(valor);
}


Certo. Agora, podemos ver que o erro está na classe ContaCorrente. 
O método saca() dessa classe chama o super.saca() que no caso, possui o 
throws na assinatura do método dizendo que ele é perigoso. Por causa disso, 
temos que tomar uma atitude: fazer um try-catch ou deixar o throws explícito na assinatura.

Dentro da nossa ContaCorrente, não faremos o try-catch então, ficará assim:

@Override
public void saca(double valor) throws SaldoInsuficienteException{
    double valorASacar = valor + 0.2;
    super.saca(valorASacar);
}

Veja que uma exceção checked dá trabalho, pois o compilador fica verificando todas 
as classes que chamam o método perigoso. A classe TesteContas também está com problemas. 
Mas, como não estávamos utilizando essa classe, adicionaremos throws na assinatura do 
método main().

public static void main(String[] args) throws SaldoInsuficienteException {}

Na hora de executar, nada vai mudar. Na execução, o unchecked é igual ao checked.


Nessa aula, aprendemos e praticamos:

como criar um bloco catch genérico usando a classe Exception;
como criar uma exceção nova SaldoInsuficienteException;
como transformar a exceção em checked ou unchecked.


Curso Java e java.util: Coleções, Wrappers e Lambda expressions
Capítulo 01 - Aula 02 - Começando com Arrays

O objetivo é entendermos os pacotes java.util e java.io 
e continuaremos a utilizar o java.lang.

Com relação ao java.lang, entenderemos melhor a nossa classe Object, 
pois temos os métodos hashCode() e equals(), isso será esclarecido 
ao falarmos sobre java.util.

Temos o projeto bytebank-herdado-conta, que finalizamos anteriormente, 
e conseguimos entendê-lo completamente, com uma exceção, vamos observar 
o código:


package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Cliente;

public class Teste {

        public static void main(String[] args) {

//Código omitido

}

Na declaração do método main, não sabemos exatamente qual é a 
função dos colchetes []. Antes de começarmos com o java.util, 
primeiro desvendaremos este mistério.

Renomearemos a classe Teste, clicando com o botão direto do mouse 
sobre ela, e selecionando "Refactor > Rename", a chamaremos de TesteObject. 
Em seguida, criaremos uma nova classe de teste, chamada Teste, com o 
seguinte conteúdo:

package br.com.bytebank.banco.test;

public class Teste {

       public static void main(String[] args) {

       }
       
}

Por que existem os colchetes []?

Imaginemos que queremos armazenar um conjunto de dados, 
por exemplo, as idades de cinco pessoas, para isso, utilizamos as variáveis:

package br.com.bytebank.banco.test;

public class Teste {

        public static void main(String[] args) {

            int idade1 = 29;
            int idade2 = 39;
            int idade3 = 19;
            int idade4 = 69;
            int idade5 = 59;

        }
        
}


Para cinco idades, isto pode até funcionar, 
mas quando trabalhamos com um grande número de dados, por exemplo, 
cem idades, já se torna inviável. Precisamos de formas mais enxutas 
de armazenamento de dados, e para isso existem as estruturas de dados.

Conheceremos agora nossa primeira estrutura de dados, que se chama array.

Raramente os arrays serão utilizados da forma como faremos agora, ou seja, 
manualmente.

Arrays são colchetes ([]) associados a algum tipo de dados, no caso, 
queremos apresentar idade que, como vimos, são do tipo int. Assim, 
o array será do tipo int. Em seguida, precisaremos de um nome para a 
variável, que será idades:


package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades;

            int idade1 = 29;
            int idade2 = 39;
            int idade3 = 19;
            int idade4 = 69;
            int idade5 = 59;

        }
        
}


Os colchetes ([]) também poderiam estar posicionados após o nome da variável, 
da seguinte forma int idades[].

Um array também é um objeto, assim sendo, precisamos criá-lo, 
pois temos uma referência que ainda não foi inicializada:


package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[];

            int idade1 = 29;
            int idade2 = 39;
            int idade3 = 19;
            int idade4 = 69;
            int idade5 = 59;

        }
        
}


O compilador aponta um erro de compilação. Isso porque, ao criar o array, 
precisamos informar o seu tamanho. Quantas idades queremos guardar? 5, 
portando, o tamanho do nosso array é 5:


package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[5];

            int idade1 = 29;
            int idade2 = 39;
            int idade3 = 19;
            int idade4 = 69;
            int idade5 = 59;

        }
}

Assim que inserimos o tamanho do array o código volta a compilar.

Internamente, temos um processo que começa com uma pilha de execução, 
representada pelo método main. Nesta pilha, ou seja, no método, foi criada 
uma variável idades.

Esta variável é um array, que como vimos, é um objeto. Os objetos 
ficam armazenados na memória HEAP. Assim, idades é uma referência que 
aponta para um objeto na memória, capaz de guardar cinco idades.

Como podemos acessar uma das posições? Utilizamos a variável como referência 
e precisamos informar a posição que queremos acessar dentro de 
colchetes ([]). Por exemplo, se quisermos acessar a primeira posição, 
ela é representada pelo número 0:


package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[5];

            idades[0]

            int idade1 = 29;
            int idade2 = 39;
            int idade3 = 19;
            int idade4 = 69;
            int idade5 = 59;

        }
}


Nos será devolvido o valor que estiver armazenado na referida posição. 
Por enquanto, este valor é 0 já que, por padrão, ao criarmos um array ele é 
inicializado com 0 em todas as posições:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {
        
        	//inicializa o array com os valores padroes
            int[]idades = new int[5]; 

            idades[0]

            int idade1 = 29;
            int idade2 = 39;
            int idade3 = 19;
            int idade4 = 69;
            int idade5 = 59;

        }
        
}


O primeiro valor padrão do tipo int disponível é 0.

Acessando o array na posição 0, ele nos retorna o valor desta posição, 
que no nosso caso é a idade1. Podemos apagar os dados que havíamos preenchido 
anteriormente:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[5]; //inicializa o array com os valores padroes

            int idade1 = idades[0];

            System.out.println(idade1);

        }
        
}

Ao executarmos, temos o seguinte resultado no console:
0

Ele nos imprimiu o valor presente na posição 0, que por coincidência, 
também é 0. Mas não queremos que seja 0, de acordo com nossos dados, 
ele deve ser 29. Para isso, inicializaremos o nosso array.

Utilizamos primeiro a referência do array, idades, seguida pelos 
colchetes ([]), que devem ser preenchidos com a posição que desejamos 
utilizar, no caso 0, e ao fim, informamos o valor que desejamos armazenar, 
no caso, 29:

package br.com.bytebank.banco.test;

public class Teste {

       //Array []
       public static void main(String[] args) {

           int[]idades = new int[5]; //inicializa o array com os valores padroes

           idades[0] = 29;

           int idade1 = idades[0];

           System.out.println(idade1);

       }
}

Isso significa que estamos armazenando no primeiro espaço de memória que 
criamos, como falamos acima. O 29 está no índice zero, ou seja, 
na primeira posição 1 e o resultado do codigo executado acima seria 29.

Com isso, podemos inicializar as demais posições do array:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {
        
        	//inicializa o array com os valores padroes
            int[]idades = new int[5];

            idades[0] = 29;
            idades[1] = 39;
            idades[2] = 49;
            idades[3] = 59;
            idades[4] = 69;

            int idade1 = idades[0];

            System.out.println(idade1);

        }
        
}

Tentaremos acessar, por exemplo, a posição 4:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[5]; //inicializa o array com os valores padroes

            idades[0] = 29;
            idades[1] = 39;
            idades[2] = 49;
            idades[3] = 59;
            idades[4] = 69;

            int idade1 = idades[4];

            System.out.println(idade1);

        }
}


e o resultado é 69.


Se o array tivesse, por exemplo, 50 posições, seria possível acessarmos a de 
número 49:


package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[50]; //inicializa o array com os valores padroes

            idades[0] = 29;
            idades[1] = 39;
            idades[2] = 49;
            idades[3] = 59;
            idades[4] = 69;

            int idade1 = idades[49];

            System.out.println(idade1);

        }
}

Ao executarmos o programa, temos o seguinte resultado no console: 0

Isso porque não inicializamos essa posição, logo, nos é fornecido o valor 
padrão.

E o que acontece se tentarmos acessar uma posição que não existe? 
voltaremos a definir o array com 5 posições, e tentaremos novamente 
acessar a de número 49:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[5]; //inicializa o array com os valores padroes

            idades[0] = 29;
            idades[1] = 39;
            idades[2] = 49;
            idades[3] = 59;
            idades[4] = 69;

            int idade1 = idades[49];

            System.out.println(idade1);

        }
}

Executaremos o programa, e temos o seguinte resultado no console:

Exception in thread "main" java.long.ArrayIndexOutOfBoundsException: 49
        at br.com.bytebank.banco.test.Teste.main(Teste.java:16)


Um erro ocorre. Este tipo de erro, inclusive, é bastante comum. 
É uma exceção unchecked, não somos obrigados a fazer nenhum tratamento.

Os arrays nos permitem ainda que perguntemos o seu tamanho. 
Criaremos um System.out.println(), utilizando a referência idades, e 
chamando o atributo length - notamos que não é um método pois não é 
acompanhado de parênteses:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {
        
        	//inicializa o array com os valores padroes
            int[]idades = new int[5];

            idades[0] = 29;
            idades[1] = 39;
            idades[2] = 49;
            idades[3] = 59;
            idades[4] = 69;

            int idade1 = idades[4];

            System.out.println(idade1);

            System.out.println(idades.length);

        }
}

Com a posição de volta para 4, na impressão, 
executaremos o programa e temos o seguinte resultado no console:

69
5

Ou seja, temos em primeiro lugar o valor armazenado na quarta 
posição, 69, e, em seguida, o tamanho do nosso array, que possui 
um total de 5 posições.

Veremos agora como podemos inicializar um array dentro de um laço. 
Primeiro, apagaremos todo o código referente a inicialização que acabamos 
de criar.

Definiremos a primeira posição como 0, portanto, i = 0. O limite do laço 
será o número de posições, assim, utilizaremos o atributo que acabamos de 
aprender idades.length. Por fim, incrementaremos com o i++:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {
        
        	//inicializa o array com os valores padroes
            int[]idades = new int[5]; 

            for(int i = 0; i < idades.length; i++) {

            }

        }
}

O próximo passo é a inicialização do array, dentro do laço.

Como i representa as posições, é esta variável que utilizaremos na 
inicialização, e que receberá i * i:


package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[5]; //inicializa o array com os valores padroes

            for(int i = 0; i < idades.length; i++) {
                idades[i] = i * i;

            }

        }
}

Em seguida, teremos o mesmo laço, mas dentro desta segunda representação 
faremos a impressão dos valores:

package br.com.bytebank.banco.test;

public class Teste {

        //Array []
        public static void main(String[] args) {

            int[]idades = new int[5]; //inicializa o array com os valores padroes

            for(int i = 0; i < idades.length; i++) {
                idades[i] = i * i;
            }

            for(int i = 0; i < idades.length; i++) {
                System.out.println(idades[i]);
            }

        }
}


Executaremos, e temos o seguinte resultado no console:

0
1
4
9
16


Aula 05 - Array de referências

Como arrays são objetos, para criarmos um novo, utilizamos a palavra new:

public class Teste {

        public static void main(String[] args) {
            int[] idades = new int[5];

        }
        
}

Precisamos definir qual tipo de dados são armazenados, no caso, 
utilizamos o int. Indicamos que se tratam de arrays por meio do 
uso de colchetes ([]), os utilizamos tanto ao declarar o tipo, quanto 
ao definir o tamanho do array. Todo array deve ter um tamanho fixo, 
pré-definido.

No nosso caso, definimos o tamanho como 5, isso significa que, 
na memória onde os objetos são armazenados é criado um espaço suficiente 
para que sejam guardados cinco números inteiros.

Automaticamente, o array é inicializado com o valor padrão do tipo 
definido, como aqui utilizamos o int, o valor padrão inicial é 0.

Em seguida, vimos como podemos acessar um array. No caso, fizemos um 
laço e criamos um mecanismo que nos permite acessar cada posição:

public class Teste {

        public static void main(String[] args) {
            int[] idades = new int[5];

        for(int i = 0; i < idades.length; i++) {
            idades[i] = i * i;
        }
    }
    
}

Utilizamos a referência idades, e os colchetes ([]), para indicarmos qual 
posição pretendemos acessar. Importante lembrar que para os arrays, 
as posições iniciam em 0, ou seja, a primeira posição é representada 
pelo número 0.

Mas não esclarecemos anteriormente, o real significado de String[] na 
assinatura do método main.

Temos que ter em mente que String é um tipo, uma classe, não um primitivo. 
Ou seja, o que fazemos ao declarar:

//Código omitido

public static void main(String[] args) {

//Código omitido

}

É declarar um array de referência.

Renomearemos a classe Teste, para TesteArrayDePrimitivos, 
e em seguida criaremos uma nova classe, um novo teste, 
chamado TestArrayReferencias, com um método main:


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

        }

}

Por que um array de referências? para estarmos preparados caso surja a 
necessidade de armazenamos diversas contas. E se tivermos 10 contas? 
onde guardaríamos as 10 referências? Uma possibilidade seria guardá-las 
dentro de um array.

Primeiro, vamos trabalhar com a classe ContaCorrente, onde iremos armazenar 
10 contas correntes, declararemos então o tipo, onde iremos indicar que se 
trata de um array, incluiremos os colchetes ([]), após ContaCorrente e chamaremos
a variável de contas. Utilizaremos o new para indicar que estamos 
criando um novo objeto, repetindo o tipo, e os colchetes ([]), 
além do número total de contas que pretendemos armazenar, no caso, 5:


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];

        }

}

Criamos um objeto que pode guardar cinco referências de contas correntes. 
Quantas contas foram de fato criadas? nenhuma. Temos por enquanto somente 
o compartimento capaz de armazená-las.

Dentro deste array não há primitivos, mas podem viver referências, 
estas por sua vez, serão inicializadas com os valores padrões.

Como criamos uma ContaCorrente, qual é o seu valor padrão? No caso, 
é null. Por isso, não podemos dizer que foi criada alguma conta, 
pois o array não aponta para nenhum objeto.

Em seguida, criaremos uma ContaCorrente cc1, com seus respectivos 
dados de agência e número:


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];

                ContaCorrente cc1 = new ContaCorrente(22, 11);

        }

}

A ideia é que, agora, criamos o nosso primeiro objeto. 
Temos uma referência cc1 que aponta para ele. Em seguida, 
nosso objetivo será armazená-lo na primeira posição em nosso array.

Como acessamos a primeira posição do array? primeiro, utilizamos o nome, 
em seguida fazemos a referência à posição entre colchetes ([]), 
para então atribuirmos o valor, cc1:


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];

                ContaCorrente cc1 = new ContaCorrente(22, 11);

                contas[0] = cc1;

        }

}


Internamente, é criada uma cópia do valor cc1, que é armazenada na primeira 
posição e aponta para o objeto.

Criaremos em seguida mais um objeto, cc2:


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);

        }

}

Temos mais uma referência em nosso código, 
apontando para este novo objeto. O próximo passo é armazenamos uma 
cópia desta cópia dentro do nosso array.

Para acessarmos a segunda posição, utilizamos o número 1, e 
atribuímos o valor cc2:


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

        }

}

Testaremos nosso código, tentaremos acessar o número da segunda conta 
a partir do nosso array. Criaremos um System.out.println(), com o método 
getNumero():


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                System.out.println(cc2.getNumero());

        }

}

Mas não queremos acessar o objeto diretamente, queremos acessar a cópia 
que armazenamos. Como podemos fazer isso? Temos de fazer a referência ao 
array, utilizando a palavra contas, e incluir a posição que desejamos acessar,
no caso a segunda posição, representada pelo número 1:

package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                //System.out.println(cc2.getNumero());

                System.out.println(contas[1].getNumero());
        }

}

Executaremos e temos o seguinte resultado no console:
22


se tentarmos acessar a posição 0:

package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                //System.out.println(cc2.getNumero());

                System.out.println(contas[0].getNumero());
        }

}

temos o seguinte resultado: 
11


Se tentarmos acessar a terceira posição:

package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                //System.out.println(cc2.getNumero());

                System.out.println(contas[2].getNumero());
        }

}

Temos o seguinte resultado:


Exception in thread "main" java.long.NullPointerException
        at br.com.bytebank.banco.test.TestArrayReferencias.main
        (TestArrayReferencias.java:20)


Pois ela ainda não foi inicializada e, por padrão, tem o valor null.

Retornaremos para a impressão da segunda posição:


package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                //System.out.println(cc2.getNumero());

                System.out.println(contas[1].getNumero());
        }

}

Estamos acessando o contas[1] e, em contrapartida, nos será devolvido um valor, 
que é uma referência. Mas onde ela é armazenada? em uma variável, 
que por sua vez, tem que ter um tipo.

No nosso caso, o tipo da variável é ContaCorrente. Assim, nosso retorno é uma 
referência do tipo ContaCorrente:

package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                //System.out.println(cc2.getNumero());

                System.out.println(contas[1].getNumero());

                ContaCorrente ref = contas[1];
        }

}

Aqui, chamamos nossa referência de ref, ela tem o mesmo valor de cc2, 
ou seja, aponta para o objeto ContaCorrente.

Assim, podemos utilizar o ref.getNumero() para imprimirmos o número da conta. 
Executaremos:

package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                //System.out.println(cc2.getNumero());

                System.out.println(contas[1].getNumero());

                ContaCorrente ref = contas[1];

                System.out.println(ref.getNumero());
        }

}


e obtivemos o seguinte resultado: 

22
22

Indicando que nosso código funcionou.

Este último System.out.println() equivale a System.out.println(cc2.getNumero()):

package br.com.bytebank.banco.test;

public class TestArrayReferencias {

        public static void main(String[] args) {

                //int[] idades = new int[5];
                ContaCorrente[] contas = new ContaCorrente[5];
                ContaCorrente cc1 = new ContaCorrente(22, 11);
                contas[0] = cc1;

                ContaCorrente cc2 = new ContaCorrente(22, 22);
                contas[1] = cc2;

                //System.out.println(cc2.getNumero());

                System.out.println(contas[1].getNumero());

                ContaCorrente ref = contas[1];
                System.out.println(cc2.getNumero());
                System.out.println(ref.getNumero());
        }

}



se executarmos, temos o seguinte resultado:
22
22
22

Portanto, quantas contas criamos afinal? Duas. Quantos objetos criamos? Três. 
Já referências, temos 9, destas, 
apenas 6 foram inicializadas.


 há uma forma literal de criar um objeto array. 
 Literal, nesse contexto, significa usar valores 
 diretamente, menos burocrático, mais direito. Veja a diferença:
 

int[] refs = {1,2,3,4,5};



Nessa aula sobre Arrays aprendemos:

 - Um array é uma estrutura de dados e serve para guardar elementos 
 (valores primitivos ou referências)
 - Arrays usam colchetes ([]) sintaticamente
 - Arrays têm um tamanho fixo!
 - Um array também é um objeto!
 - Arrays são zero-based (o primeiro elemento se encontra na posição 0)
 - Um array é sempre inicializado com os valores padrões.
 - Ao acessar uma posição inválida recebemos a exceção ArrayIndexOutOfBoundException
 - Arrays possuem um atributo length para saber o tamanho
 - A forma literal de criar uma Array, com o uso de chaves {}.


Capítulo 02  - Aula 01 Array do tipo Object


Na nossa classe TestArrayReferencias criamos um array com cinco contas correntes. 
Se quiséssemos guardar contas poupanças, poderíamos então criar um novo array para estas. 
Mas e se quiséssemos guardar contas dos dois tipos? Qual deveria ser o tipo do array nesse caso?

A primeira resposta seria Conta[], lembrando que precisamos importar Conta, 
que seria mais genérico, assim teríamos o seguinte código:


package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        //Código omitido
        
}


Assim, poderíamos apontar tanto para uma ContaCorrente, quanto para uma ContaPoupanca. 
Isso não influencia no restante do código, que continua compilando:

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaCorrente cc2 = new ContaCorrente(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        }

}

Em seguida, tentaremos criar um objeto do tipo ContaPoupanca():

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaCorrente ref = contas[1];
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}


Isso também funciona, porque nosso array é do tipo mais genérico, Conta[].

Entretanto, em ContaCorrente ref = contas[1] o compilador aponta um erro. 
Por que? Quais são os tipos de referências que o nosso array é capaz de armazenar? 
Temos que observar a linha Conta[] contas = new Conta[5], a partir da qual concluímos 
que nosso array é capaz de armazenar referências do tipo Conta.

Do jeito como está em nosso código:

//Código omitido

ContaCorrente ref = contas[1];

//Código omitido


A posição 1 guarda uma referência do tipo ContaCorrente. Entretanto, a nossa 
referência aponta para um objeto do tipo ContaPoupanca. É possível referenciar 
um objeto do tipo ContaPoupanca por meio de um do tipo ContaCorrente? Não, isto não é possível.

Por isso o compilador reclama, em contas:

//Código omitido

        ContaCorrente ref = contas[1];

//Código omitido


O computador sabe que a referência contas, no array, é do tipo Conta[], 
por esse motivo, não podemos armazená-la em um tipo ContaCorrente.

Para que o código possa compilar, precisamos alterar, de ContaCorrente, para Conta:

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        Conta ref = contas[1];
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}

Assim, o Java consegue garantir que nos devolverá uma referência do tipo Conta.

Testaremos o código, executando-o. Temos o seguinte seguinte resultado no console:

22
22
22


Como sabemos que a:
 
//Código omitido

        Conta ref = contas[1];

//Código omitido


Aponta para um objeto do tipo ContaPoupanca, se escrevêssemos:


package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaPoupanca ref = contas[1];
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}


Poderia funcionar. Entretanto, vemos que o compilador também não permite. 
Isso acontece porque o compilador não verifica a linha onde é criado o objeto 
ContaPoupanca(), o que ele faz é verificar o array, e buscar o tipo de referência nele contido.

É do tipo Conta, ou seja, mais genérica. Isso significa que ela poderia apontar 
tanto para ContaCorrente, quanto para ContaPoupanca. Por esse motivo o compilador 
aponta o erro, pois diante dessa dualidade, ele não tem certeza se a seguinte linha 
de código funcionará:

//Código omitido

ContaPoupanca ref = contas[1];

//Código omitido


Como nós estamos controlando a execução, sabemos que esta posição do array 
aponta para o objeto ContaPoupanca. ref é um objeto do tipo ContaPoupanca(), portanto, 
aponta para o objeto ContaPoupanca.

Por isso, queremos informar ao compilador que isso vai funcionar, que nós temos conhecimento 
de o código irá compilar. Fazemos isso por meio de um cast de referências. Transformamos uma 
referência de um tipo mais genérico, para uma de um tipo mais específico. Isso pode ser chamado 
também de type cast:

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaPoupanca ref = (ContaPoupanca) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}


Testaremos. Executaremos e temos o seguinte resultado no console:

22
22
22

Funcionou!

Como sabemos, a referência aponta para um objeto do tipo ContaPoupanca.

E se tivéssemos a situação contrária? em vez de ContaPoupanca, utilizaremos ContaCorrente:


package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaCorrente ref = (ContaCorrente) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}

Testando, vemos que no console é exibida a exceção de class cast exception.

Fizemos um cast de uma referência genérica para uma mais específica, entretanto, 
ele não funcionou. O objeto ref é do tipo ContaPoupanca, por isso nosso cast não funcionando, 
pois não direcionamos para a referência mais específica correta.

Retornaremos à versão do código que está compilando:

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Conta[] contas = new Conta[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaPoupanca ref = (ContaPoupanca) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}

E se quisermos inicializar um array capaz de armazenar qualquer tipo de referência? 
Precisaríamos do tipo mais genérico possível, neste caso, seria do tipo Object.

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Object[] contas = new Object[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaPoupanca ref = (ContaPoupanca) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}


Nesse array, podemos guardar qualquer objeto. Criaremos um Cliente:

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Object[] contas = new Object[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        Cliente cliente = new Cliente();

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaPoupanca ref = (ContaPoupanca) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}


No array contas, no índice 2, guardaremos a referência que se chama cliente:

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Object[] contas = new Object[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        Cliente cliente = new Cliente();
        contas[2] = cliente;

        //System.out.println(cc2.getNumero());

        System.out.println( contas[1].getNumero() );

        ContaPoupanca ref = (ContaPoupanca) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}

Entretanto, a linha:

//Código omitido

System.out.println( contas[1].getNumero() );

//Código omitido


Parou de funcionar. Isso porque o tipo de referência no índice 1 é Object, 
e utilizamos esta referência genérica para chamar o método getNumero(). 
Na classe Object existe este método? Não existe. Por esse motivo, temos um erro de compilação.

Isso só funcionará se fizermos um cast, ou seja, se transformarmos uma referência 
genérica em uma específica. Comentaremos as linhas de código referentes a esta seção 
que não está compilando:

package br.com.bytebank.banco.test;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Object[] contas = new Object[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        contas[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        contas[1] = cc2;

        Cliente cliente = new Cliente();
        contas[2] = cliente;

        //System.out.println(cc2.getNumero());

        //Object referenciaGenerica = contas[1];

        //System.out.println( referenciaGenerica.getNumero() );

        ContaPoupanca ref = (ContaPoupanca) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}

Renomearemos a variável contas, clicando com o botão direito do mouse sobre ela, 
e selecionando a opção "Refactor > Rename...", ela passará a se chamar referencias:

//Código omitido

public class TestArrayReferencias {

        public static void main(String[] args) {

        //int[] idades = new int[5];
        Object[] referencias = new Object[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        referencias[0] = cc1;

        ContaPoupanca cc2 = new ContaPoupanca(22, 22);
        referencias[1] = cc2;

        Cliente cliente = new Cliente();
        referencias[2] = cliente;

        //System.out.println(cc2.getNumero());

        //Object referenciaGenerica = contas[1];

        //System.out.println( referenciaGenerica.getNumero() );

        ContaPoupanca ref = (ContaPoupanca) contas[1]; //type cast
        System.out.println(cc2.getNumero());
        System.out.println(ref.getNumero());

        }

}



Nessa capítulo aprendemos:

- uma array do tipo Object pode guardar qualquer tipo de referência
- quando convertemos uma referência genérica para uma referência mais específica 
é preciso usar um type cast
- o cast só compila quando é possível, mesmo assim pode falhar na hora de rodar
- quando o type cast falha podemos receber uma ClassCastException
- para receber valores ao chamar o programa Java na linha de comando podemos usar o 
array String[] no método main



Capítulo 03 - 01  Adapter para arrays

agora iremos trabalhar com a sintaxe utilizada para criar um objeto comum. 
Até o momento, utilizamos a seguinte:


//Código omitido, pacote e import

public class TestArrayReferencias {

        public static void main(String[] args ) {

        //int[] iaddes = new int[5];
        Object[] referencias = new Object[5];

        ContaCorrente cc1 = new ContaCorrente(22, 11);
        referencias[0] = cc1;

        //Código omitido
        
}


Temos no lado esquerdo, a referência e o tipo, e no lado direito o new, 
que chama o construtor, com seus parâmetros, caso haja - este é o padrão 
para qualquer padrão que queiramos criar, exceto pelo array, que possui 
uma sintaxe própria.

No array, utilizamos os colchetes ([]), e no lado direito utilizamos 
o new e chamamos algo análogo a um construtor mas que, dentro de 
colchetes ([]), recebe o tamanho do referido array.

Outro ponto que aprendemos é que, para descobrirmos o tamanho de um array, 
utilizamos o referencias.length, que é um atributo público. 
Estes são geralmente considerados como uma má prática.

Além disso, normalmente, não queremos saber quantas referências um 
array pode guardar. No nosso exemplo, são 5, mas o importante é sabermos 
quantas referências um array de fato já guardou, neste caso, seriam 2, 
representadas por cc1 e cc2.

E se criarmos um array com 5 posições, para guardar 5 referências,
mas no decorrer do projeto percebermos a necessidade de guardar mais 5. 
O array não é dinâmico, ou seja, uma vez criado com um determinado número 
de posições, ele só terá aquele número. Assim, precisamos descobrir uma 
forma de trabalharmos com esta ferramenta mais elegantemente.




Aula 013 - Outras formas de inicialização


Falamos que o ArrayList é um array dinâmico, ou seja, por baixo dos panos é usado um array, mas sem se preocupar com os detalhes e limitações.

Agora pense que você precisa criar uma lista representando todos os 26 estados do Brasil. Você gostaria de usar um ArrayList para "fugir" 
do array, mas sabe que o ArrayList cria um array automaticamente, do tamanho que a classe acha conveniente.

Será que não há uma forma de criar essa lista já definindo o tamanho do array? Claro que tem e é muito simples. 
O construtor da classe ArrayList é sobrecarregado e possui um parâmetro que recebe a capacidade:

ArrayList lista = new ArrayList(26); //capacidade inicial

A lista continua dinâmica, mas o tamanho do array inicial é de 26!


Lista a partir de outra

Outra forma de inicializar uma lista é baseado na outra que é muito comum no dia a dia. 
Para tal a ArrayList possui mais um construtor que recebe a lista base:


ArrayList lista = new ArrayList(26); //capacidade inicial
lista.add("RJ");
lista.add("SP");
//outros estados
ArrayList nova = new ArrayList(lista); //criando baseado na primeira lista



O que foi visto neste capítulo:
Nessa aula começamos a falar sobre lista e conhecemos a classe java.util.ArrayList. Aprendemos:

- que a classe java.util.ArrayList encapsula o uso do array e oferece vários métodos de mais alto nível
- que uma lista guarda referencias
- como usar métodos size, get, remove
- como usar o foreach para iterar a ArrayList
- que os generics parametrizam classes
- que no caso da ArrayList podemos definir o tipo dos elementos através de generics




Capitulo 04 - Aula 01

O método equals

O método contains(), verifica se a lista possui determinado elemento, 
por exemplo cc2, o contains() nos retorna um boolean, true ou false, 
dependendo da existência deste elemento ou não.


o contains() utiliza por padrão chama-se equals(), para fazer comparação
 identificar quando há objetos iguais ainda que tenham referências distintas, 
 teremos que alterar o método para que siga o padrão definido pela classe Object.

Assim sendo, devemos sobrescrever este método. Isso nos permitirá definir nosso próprio 
critério de igualdade, que neste caso, trata-se de uma regra de negócio.



List e LinkedList:


O ArrayList é uma lista, mas não é a única. Por que então utilizar outra?

Como qualquer outra, esta modalidade possui vantagens e desvantagens. 
Como lado positivo, temos as características de um array, ou seja, 
o acesso fácil a qualquer elemento aleatório. Se adicionamos elementos em um array, 
e queremos acessar qualquer posição, não há nenhum trabalho a mais para que façamos isso, 
esse acesso pode ser feito diretamente pelo índice de forma bastante facilitada.

Além disso, adicionar novos elementos em um array é um processo simples, 
desde que não seja ultrapassada sua capacidade de armazenamento. Se desejarmos 
adicionar um novo elemento, o ArrayList sabe automaticamente qual a próxima posição 
livre, e ele é inserido - simples. Iteração também é algo tranquilo de se fazer em um array.

Do lado negativo, temos que a sua capacidade é limitada ao seu tamanho no momento da 
criação, ou seja, uma vez que sua capacidade acaba, é necessária a criação de um novo 
array, com capacidade maior, e copiar os elementos daquele para este armazenamento. 
Ainda, se quisermos remover um elemento, o array não permitirá que existam "buracos" 
em sua lista e, sendo assim, moverá todas as referências de modo que todos os índices 
serão modificados. Para esse tipo de operação, o ArrayList não é tão eficiente.

Se o objetivo for simplesmente adicionar elementos, para depois fazer a iteração, 
o ArrayList é sem dúvida o mais indicado. É esse o tipo mais comum de situação e, 
normalmente, o uso mais comum. Contudo, é necessário sabermos destas ressalvas.


Qual seria, então, a alternativa ao ArrayList? Para isso, temos o LinkedList. 
Ele não utiliza um array internamente.

Isso significa que, quando falamos de List nem sempre estamos lidando com arrays. 
Uma lista significa, simplesmente, que estamos armazenando elementos em sequência, 
ou seja, o primeiro elemento adicionado também é o primeiro que será retornado. 
Além disso, temos um índice, e métodos que trabalham com ele. Por exemplo, o método get(), 
que podemos utilizar para obter determinado elemento de uma posição em particular.

No LinkedList temos estas mesmas características, sequência, ordem de inserção e índice. 
Entretanto, ela não funciona com um array internamente.

Seu funcionamento ocorre da seguinte forma: ao adicionarmos, por exemplo, cc1 e, em seguida, 
cc2, ela se lembrará do elemento que foi adicionado anteriormente, ou seja, cc2 se lembra de 
cc1, cc3 de cc2, e assim por diante. Da mesma forma, o primeiro elemento se lembra daquele que 
o segue, ou seja, cc1 lembra de cc2, cc2 de cc3, e assim sucessivamente. A isso, damos o nome 
de lista duplamente encadeada.


Neste tipo de lista, apagar um elemento não causa grande impacto à ela como um todo, 
ela o descarta e substitui com o seguinte e o anterior. Supondo que temos cc1, cc2 e cc3, 
ao apagarmos cc2, simplesmente cc1 e cc3 passarão a ser diretamente conectados.

Mas e se quisermos acessar o último elemento da lista, como podemos acessá-lo? 
Temos que iniciar no primeiro elemento, e verifica-los sucessivamente, até atingirmos o 
ponto onde não há mais continuidade. Diferentemente do array, não temos como acessar uma 
determinada posição diretamente. Se quisermos, por exemplo, acessar a posição 3, temos que 
iniciar na primeira e seguir, até atingirmos a desejada. Isso faz com que a iteração seja 
algo negativo na LinkedList.

Para adicionar elementos, a lista sabe quais são o primeiro e último elementos, e faz a 
inserção após o final.

Colocaremos em prática, utilizando a LinkedList em nossa classe TesteArrayListEquals. 
Isso será complicado, uma vez que há duplicidade de diversos métodos, como add(), contains(), 
size(), remove() e equals().

A primeira coisa a fazermos, na classe TesteArrayList, será alterarmos para LinkedList:

//Código omitido

public class TesteArrayList {

        public static void main(String[] args) {

        //Generics
        LinkedList<Conta> lista = new LinkedList<Conta>();

        ArrayList<String> nomes = new ArrayList<String();

		//Código omitido

}

O código continua funcionando, apenas substituímos o ArrayList pelo LinkedList. 
Executaremos a classe, para testarmos. Temos o seguinte resultado no console:

Tamanho da lista: 2

Numero da conta: 11

Tamanho da lista: 1

Já existe? true

ContaCorrente, Numero: 22, Agencia: 22
ContaCorrente, Numero: 311, Agencia: 33
ContaCorrente, Numero: 322, Agencia: 33
--------------------------------
ContaCorrente, Numero: 22, Agencia: 22
ContaCorrente, Numero: 311, Agencia: 33
ContaCorrente, Numero: 322, Agencia: 33

Funcionou!

Apesar de os funcionamentos internos teremos sido diferentes, obtivemos os mesmos 
resultados finais no console.

Temos então duas classes, que utilizam métodos com os mesmos nomes, mas cujas implementações 
diferem. Contudo, percebemos que há um ponto em comum, ou seja, todos aqueles que pretendem 
ser uma lista, devem contar com um método add() de alguma forma, o mesmo para o remove(), 
e assim sucessivamente, conforme citado acima.

Isso nos leva à conclusão de que existe uma interface para isso, ela se chama List. 
Ao implementarmos na classe TesteArrayList:


//Código omitido

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TesteArrayList {

        public static void main(String[] args) {

        //Generics
        List<Conta> lista = new LinkedList<Conta>();

        ArrayList<String> nomes = new ArrayList<String();

		//Código omitido
}

Assim como anteriormente, teremos que importar esta interface. Há duas importações possíveis, 
uma do pacote java.awt, e outra do java.util, neste caso, escolheremos a segunda opção:

package br.com.bytebank.teste.util;

import java.util.ArrayList;
import java.util.LinkedList;
import.java.util.List;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TesteArrayList {

        public static void main(String[] args) {

        //Generics
        List<Conta> lista = new LinkedList<Conta>();

        ArrayList<String> nomes = new ArrayList<String();

		//Código omitido
		
}


Ou seja, estamos utilizando a interface para definirmos o tipo da referência. 
Dentro da interface, podemos observar a existência de diversos métodos, uns que já 
conhecemos mas muitos outros que ainda nem exploramos.

Por fim, alteraremos o LinkedList de volta para ArrayList:

package br.com.bytebank.teste.util;

import java.util.ArrayList;
import java.util.LinkedList;
import.java.util.List;

import br.com.bytebank.banco.modelo.Conta;
import br.com.bytebank.banco.modelo.ContaCorrente;

public class TesteArrayList {

        public static void main(String[] args) {

        //Generics
        List<Conta> lista = new ArrayList<Conta>();

        ArrayList<String> nomes = new ArrayList<String();

		//Código omitido
		
}


De array para list

A partir de agora vamos usar as listas para fugir das desvantagens do array. 
No entanto, se lembra do nosso array String[] do método main? Com certeza, 
e não podemos mudar a assinatura do método main pois a JVM não aceita isso. 
Bom, já que não podemos alterar a assinatura será que não tem uma forma de 
transformar uma array em uma lista? Claro que existe, e para tal, existe já 
uma classe que ajuda nessa tarefa: java.util.Arrays


A classe java.util.Arrays possui vários métodos estáticos auxiliares para 
trabalhar com arrays. Veja como fica simples de transformar um array para 
uma lista:

public class Teste {

  public static void main(String[] args) {
    List<String> argumentos = Arrays.asList(args);
  }
}


Nessa aula aprendemos:

- como implementar o método equals para definir a igualdade
- que o método equals é utilizado pelas listas
- que existe mais uma lista, a java.util.LinkedList
- a diferença entre ArrayList e LinkedList
- a interface java.util.List que define os métodos da lista


Capitulo 05 - aula 01
 A alternativa threadsafe:

Anteriormente, falamos sobre a java.util.LinkedList e faltou abordarmos o java.util.Vector, 
que juntamente com o java.util.ArrayList são as principais implementações da interface 
java.util.List.

No que o Vector difere das demais? Ele, na verdade, é igual a um ArrayList. 
Internamente, ele também utiliza um array. O Java nasceu com um Vector e, posteriormente, 
as demais implementações foram adicionadas.

O Vector tem uma diferença importante em relação ao ArrayList, ele é o que chamamos de 
thread safe.

Como vimos, qualquer programa em Java inicia com um método main, que forma uma "pilha" e, 
a partir dele, podemos ter uma nova "pilha". Dessa forma, elas podem ser executadas em 
paralelo. O Java permite a criação de inúmeros métodos main.

Quando temos esse tipo de situação, e desejamos que as execuções sejam feitas em paralelo, 
em cima de uma mesma lista, utilizamos o java.util.Vector. Este tipo de operação só 
funciona dessa forma, o ArrayList e o LinkedList não servem.

Apesar disso, o Vector é utilizado como exceção. As ocasiões em que ele é necessário são raras, 
ou seja, é difícil termos situações como a citada acima, onde são compartilhadas entre duas ou 
mais "pilhas" uma mesma lista.

Mas e se usássemos o Vector como uma medida preventiva? Caso ele fosse ser necessário 
futuramente? Isso também não funcionaria, já que a utilização dele, em si, tem um custo 
em desempenho. Assim, se não for estritamente necessário, é melhor utilizar outros tipos de 
lista, como o ArrayList, que é mais eficiente.


Retornaremos ao código da classe TesteArrayList, onde temos implementado o Vector:

//Código omitido

public class TesteArrayList {

        public static void main(String[] args) {

                //Generics
                List<Conta> lista = new Vector<Conta>();//thread safe

                Conta cc = new ContaCorrente(22, 11);
                lista.add(cc);

                Conta cc2 = new ContaCorrente(22, 22);
                lista.add(cc2);

				//Código omitido
				
}

A interface List permanece inalterada, mas estamos utilizando a nova classe Vector, 
que é aquilo que chamamos de thread safe. Neste curso, a thread safety não é algo 
estritamente necessário, isso porque não estamos trabalhando com mais de um método main, 
ou "pilhas", como chamamos.

Ao executarmos a classe, temos o seguinte resultado no console:

Tamanho da lista: 2

Numero da conta: 11

Tamanho da lista: 1

Já existe? true

ContaCorrente, Numero: 22, Agencia: 22
ContaCorrente, Numero: 311, Agencia: 33
ContaCorrente, Numero: 322, Agencia: 33
--------------------------------
ContaCorrente, Numero: 22, Agencia: 22
ContaCorrente, Numero: 311, Agencia: 33
ContaCorrente, Numero: 322, Agencia: 33


Tudo continua funcionando normalmente.

Com isso, temos três opções de listas disponíveis para uso: LinkedList, ArrayList, ou Vector. 
Por mais que troquemos a implementação, o corpo do código permanece o mesmo, e funciona com 
qualquer um dos três tipos, graças ao polimorfismo.



Aula 04 -  A interface Collection

Até o momento, focamos em listas e nas implementações principais, 
dos principais métodos das listas. Como sabemos, as listas são sequências, 
por isso, ela sabe em qual ordem os seus elementos foram inseridos, com isso, 
ao iterar, os recebemos na mesma ordem de inserção.

Vimos tipos de implementação, como a ArrayList, o Vector - que possui o thread safe, 
e o LinkedList, que é totalmente encadeada. O que todos eles têm em comum é que são listas, 
e que aceitam duplicados. Isso significa que, se uma referência já foi adicionada, 
ela é aceita novamente pela lista. É possível adicionarmos a mesma referência diversas vezes, 
em uma mesma lista.

Neste ponto, temos um aspecto que nem sempre é desejado, nem sempre queremos ter elementos 
duplicados em nossas listas. Por exemplo, em uma lista de contas bancárias, não tem muito 
sentido haver o registro duplicado de determinado elemento. Neste contexto de negócio, não 
queremos que isto aconteça.

Entretanto, por padrão, a lista não nos fornece nenhum mecanismo que nos ajude em relação a este aspecto.

Precisamos, primeiro, verificar se determinado elemento já é presente para, somente então, 
termos segurança para adicioná-lo. Por este motivo, existe um outro mundo de conjuntos, que 
inclui o java.util.Set e java.util.HashSet. Para entendê-los melhor, é necessário conhecer 
o método hashCode().

Não se trata de sequências, os sets espalham seus elementos com base no hashCode().

Curso sobre pacote java.util ou a API de Collections, 
neste curso contém muita coisa, sobre listas e também, 
mergulhará a fundo nos conjuntos (java.util.Set) e mapas
(java.util.Map).

Curso: https://cursos.alura.com.br/course/java-collections


Disso tudo, podemos concluir que um Set não aceita elementos duplicados e que, por padrão, 
não é uma sequência. Entretanto, Tanto as listas quanto os sets compartilham um elemento 
em comum, que são as coleções do java.util.Collection. Elas podem ser tanto listas, quanto 
um conjunto de sets.

Há uma interface mãe, da List e da Set, que é a Collection.

Em nosso código, isso significa que, ao criarmos um ArrayList, 
podemos utilizar uma interface ainda mais genérica. Se observarmos o código da 
própria interface List, veremos que ela estende Collection. Por isso, se ela é 
capaz de implementar List, consequentemente, ela pode fazer o mesmo com a interface Collection.

Temos um problema, pois alguns métodos deixam de funcionar. Por exemplo, o get(), que 
trabalha com a ideia de índices. Os índices são aplicáveis somente ao conceito de listas e, 
apesar de o Collection contemplar tanto elas quanto sets, ao generalizarmos, não será possível
 utilizarmos este tipo de métodos, já que os índices não existem para o universo dos sets.

- java.util.List é a interface mãe de todas as listas.
- java.util.Collection é a interface mãe de todas as coleções.


Nessa capítulo vimos:

- o java.util.Vector, que é uma ArrayList thread safe
- a interface java.util.Collection que é a interface de todas as coleções
- as listas são sequencias que aceitam elementos duplicados
- os conjuntos (java.util.Set) também são coleções, mas não aceitam 
duplicados nem são listas



Capítulo 06 - Aula 01 Autoboxing e Unboxing

- Nos arrays primitivos, cada casa guarda o valor primitivo, enquanto que no array de referência,
 cada uma armazena a referência que é utilizada para encontrá-lo, Contudo, no mundo das listas, 
 elas só podem ser de referências. Só existem coleções de referências.

 criando um array do tipo int, primitivo, onde utilizamos os colchetes ([]), 
 da seguinte forma:
 int[] idades = new int[5]; //tamanho fixo


 variável armazenando um valor primitivo ao armazenar este valor em uma lista, 
 surgirá um problema, a lista só é capaz de guardar referências.
 Ao chamarmos o método add(), veremos que o Eclipse mostra que ele já
 espera receber uma referência do tipo Object, ou seja, se tentarmos
 adicionar o primitivo idade, não deverá funcionar, porque idade 
 não é uma referência, logo, não é compatível com o tipo Object


 Para cada primitivo no mundo Java, existe algo que o representa no mundo orientado 
 a objetos. Isso significa que, para cada tipo primitivo, há uma classe que o 
 representa.
 
 int idade = 29; // classe Integer
 
 listas -> utilizado a interface List -> importar java.util
 parametrizar o ArrayList é uma boa prática para nossas coleções
 Desta forma garantimos maior segurança, já que falamos de cast
 List<Integer> numeros = new ArrayList<Integer>();
 
 porém, seu eu colocar 29 diretamente aonde esta o idadeRef, também é aceito 
 pois, o java pegará o valor repassado e internamente cria um obj
 para armazenar a referencia dentro do array
 A ideia é auxiliar a transformação de um primitivo em objeto, e vice versa
 essa transformação se chama Autoboxing
 numeros.add(idadeRef);
 
 array de referências -> é utilizado a classe como tipo
 String[] nomes = new String[5];
 
 
 
 
 Aula 02 - Métodos da classe Integer

 A transformação do tipo primitivo para o objeto referência acontece automaticamente, 
 e é chamada de autoboxing. O caminho inverso é chamado de unboxing.

 As classes que existem para cada tipo primitivo se chamam wrappers. Isso porque elas 
 "embrulham" o tipo primitivo do objeto, que internamente guarda o valor primitivo. 
 Elas existem para que haja compatibilidade com as coleções, nos permitindo, por exemplo, 
 guardar números dentro de uma lista.

 inicialização de uma variável, utilizando primitivo
 
	 //Código omitido
	
	int idade = 29;
	
	//Código omitido
	

 inicialização com o uso de uma classe wrapper:
 
 //Código omitido

	Integer idadeRef = new Integer(29);

 //Código omitido
 
 
  Percebemos que a classe Integer aparece riscada, o que indicada que este construtor não 
  deveria mais estar sendo utilizado. Mas então, como construiremos o objeto? Neste caso, 
  o construtor é descontinuado, surge a mensagem de que 
  "The constructor Int3eger(int) is deprecated".
  
  Neste caso, para criarmos um objeto, temos que utilizar a classe, com o método estático 
  valueOf(), que receberá um primitivo int:
  
  //Código omitido

	public class Teste {
	
	        public static void main(String[] args) {
	
	                int[] idades = new int[5];
	                String[] nomes = new String[5];
	
	                int idade = 29;
	
	                Integer idadeRef = Integer.valueOf(29);
	
	                List<Integer> numeros = new ArrayList<Integer>();
	                numeros.add(29); //Autoboxing
	
	        }
	
	}
	
	o jeito mais adequado de fazermos isso em nosso código é utilizando o método valueOf(), 
	e termos como resultado uma referência. A partir desta referência idadeRef, podemos 
	chamar métodos. Por exemplo, o intValue().
	
	Temos uma referência, que aponta para um objeto, e queremos obter desta classe wrapper - 
	que embrulha o primitivo -, qual o valor que nela está contido. É para isso que o método 
	intValue() é utilizado, ele nos devolve, justamente, o primitivo:
	
	//Código omitido

	public class Teste {
	
	        public static void main(String[] args) {
	
	                int[] idades = new int[5];
	                String[] nomes = new String[5];
	
	                int idade = 29;
	
	                Integer idadeRef = Integer.valueOf(29);
	                int valor = idadeRef.intValue();
	
	                List<Integer> numeros = new ArrayList<Integer>();
	                numeros.add(29); //Autoboxing
	
	        }
	
	}
	
	Assim, estamos fazendo o autoboxing:
	Integer idadeRef = Integer.valueOf(29);
	
	Para, em seguida, fazer o unboxing:
	int valor = idadeRef.intValue();
	
	A classe Integer possui diversos métodos auxiliares, mas alguns que são essenciais são o 
	valueOf(int i), que corresponde ao autoboxing, intValue(), para o unboxing, valueOf(String s) 
	e parseInt().
	
	Temos ainda um método que nos permite transformar um Integer para outros primitivos, por exemplo, 
	em um double, neste caso, utilizamos o doubleValue():
	
	
	//Código omitido

	public class Teste {
	
	        public static void main(String[] args) {
	
	                int[] idades = new int[5];
	                String[] nomes = new String[5];
	
	                int idade = 29;
	
	                Integer idadeRef = Integer.valueOf(29); //autoboxing
	
	                System.out.println(idadeRef.doubleValue());
	
	                int valor = idadeRef.intValue(); //unboxing
	
	                String s = args[0];//"10"
	
	                //Integer numero = Integer.valueOf(s);
	
	                int numero = Integer.parseInt(s);
	
	                System.out.println(numero);
	
	                List<Integer> numeros = new ArrayList<Integer>();
	                numeros.add(29); //Autoboxing
	
	        }
	
	}
	
	Além disso, e removendo trechos de código que não são mais relevantes, 
	veremos também algumas constantes. Em alguns casos, precisaremos estabelecer, 
	por exemplo, valores mínimos e máximos para que sirvam de parâmetros em alguma 
	regra de negócio específica'. Para sabermos, por exemplo, o valor máximo, podemos 
	utilizar MAX_VALUE:

	System.out.println(Integer.MAX_VALUE);
	
	porém, temos o MIN_VALUE também:
	System.out.println(Integer.MIN_VALUE);
	
	Cada Integer é capaz de um certo limite de armazenamento, de 4 Bytes
	
	Podemos, ainda, descobrir o tamanho do Integer, utilizando o SIZE:
	System.out.println(Integer.SIZE);
	
	Indicando um tamanho de 32 bits. Se quisermos saber a quantidade de bytes, utilizamos o BYTES:
	System.out.println(Integer.BYTES);
	
	documentação: https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html
	
	
	O Autoboxing / unboxing pode ser confuso. Será que você desmistifica o código abaixo?
	
	public class TesteWrapper {

	    public static void main(String[] args){
	        Integer ref = Integer.valueOf("3");
	        ref++;
	        System.out.println(ref);
	    }
	    
	}
	
	compila! 
	Retorna 4.
	realmente incrementa o valor inteiro, mesmo sendo uma referência. O que acontece por baixo 
	dos panos é um autoboxing / unboxing na linha que incrementa a variável (ref++). 
	Você pode imaginar que essa linha será substituída por três novas:
	
	int valor = ref.intValue();
	valor = valor + 1;
	ref = Integer.valueOf(valor);
	
	O valor é "desembrulhado", depois incrementado e depois "embrulhado" de novo.
	
	
	Aula 06 - A classe number
	
	Pontos flutuantes:
	(8 bytes) double < - > java.lang.Double
	(4 bytes) float < - > java.lang.Float
	
	Inteiros:
	(8 bytes) long < - > java.lang.Long
	(4 bytes) int < - > java.lang.Integer
	(2 bytes) short < - > java.lang.Short
	(1 byte) byte < - > java.lang.Byte
	 
	Character:
	(2 bytes) char < - > java.lang.Character
	
	Boolean:
	boolean < - > java.lang.Boolean
	
	
	todas essas classes citadas acimas, tirando boolean e char, são numbers, então:
	
	Todas elas pertencem a Classe mãe java.lang.Number
	
	
	o tipo boolean. Este possui uma particularidade, já que deve possuir dois valores, 
	um para representar o verdadeiro, true, e outro que representa o falso, false. Eles já existem, 
	como constantes, TRUE e FALSE.
	
	
	Importante notar que, no Java, as constantes são sempre escritas em letras maiúsculas.
	
	
	 temos tipos flutuantes e inteiros, e o que eles têm em comum é que ambos são numéricos. 
	 Assim, há uma classe mãe que os conecta, a java.lang.Number. Seguinte este conceito, as 
	 seguintes classes a estendem: Double, Float, ambas flutuantes, Long, Integer, Short e Byte, 
	 representando os inteiros.
	
	
	Pensando em herança, e no polimorfismo, quais seriam então os métodos definidos pela classe 
	Number? Há diversos, dentre eles, podemos citar byteValue(), doubleValue() e floatValue(), 
	todos métodos que já estudamos quando abordamos a classe Integer
	
	A existência de primitivos e wrappers é explicada pelo momento da criação do Java, 
	à época, a capacidade de processamento das máquinas era limitado, e a memória era custosa, 
	portanto, pensando em questões de desempenho, e memória, importante a existência dos primitivos. Eles são mais rápidos, e ocupam menos espaço.

	Hoje, isso não é mais um problema, sua existência se justifica apenas historicamente, 
	como um legado.
	
	
	Nessa aula focamos nas classes WRAPPERS e aprendemos que

	- para cada primitivo existe uma classe chamada Wrapper
	- para guardar um primitivo numa coleção é preciso criar um objeto que embrulha o valor
	- a criação do objeto Wrapper é chamada de autoboxing
	- a retirada do valor primitivo do objeto Wrapper é chamada de unboxing
	- autoboxing e unboxing acontecem automaticamente.
	- as classes wrapper possuem vários métodos auxiliares, por exemplo para o parsing
	- todas as classes wrappers que representam um valor numérico possuem a classe 
	java.lang.Number como mãe
	
	
	Capitulo 07 - Ordenando listas
	
	O algorítimo de ordenação do Java já está implementado, o desenvolvedor não precisa 
	ter esta preocupação.
	
	No nascimento do pacote java.util havia uma classe separada, destinada exclusivamente 
	à função de ordenação. Entretanto, em versões mais recentes da linguagem, houve a 
	implementação de um método específico, tendo em mente a orientação a objetos.
	
	O método utilizado chama-se sort(), e exige um "Comparator", c. Ele representa o 
	critério de ordenação, serve para comparar duas referências, por meio de um método 
	presente na interface Comparator.
	
	
	criando uma nova classe e adicionando algumas contas:
	
	package br.com.bytebank.banco.test.util;

	import java.util.ArrayList;
	import java.util.Comparator;
	import java.util.List;
	
	import br.com.bytebank.banco.modelo.Conta;
	import br.com.bytebank.banco.modelo.ContaCorrente;
	import br.com.bytebank.banco.modelo.ContaPoupanca;
	
	public class Teste {
	
	        public static void main(String[] args) {
	
	                Conta cc1 = new ContaCorrente(22, 33);
	                cc1.deposita(333.0);
	
	                Conta cc2 = new ContaPoupanca(22, 44);
	                cc2.deposita(444.0);
	
	                Conta cc3 = new ContaCorrente(22, 11);
	                cc3.deposita(111.0);
	
	                Conta cc4 = new ContaPoupanca(22, 22);
	                cc4.deposita(222.0);
	
	                List<Conta> lista = new ArrayList<>();
	                lista.add(cc1);
	                lista.add(cc2);
	                lista.add(cc3);
	                lista.add(cc4);
	
	        }
	
	}
	
	class NumeroDaContaComparator implements Comparator<Conta> {
	}
	
	
	Contudo, a classe NumeroDaContaComparator não está compilando. Isso acontece porque 
	ainda precisamos 
	implementar o método compare(). Com a ajuda do Eclipse, clicaremos sobre o ícone de lâmpada, 
	que aparece ao lado esquerdo da linha que não compila, e ela nos dará a opção 
	"Add unimplemented methods". Temos assim a seguinte formulação automática, criada pelo Eclipse:
	
	class NumeroDaContaComparator implements Comparator<Conta> {

	        @Override
	        public int compare(Conta arg0, Conta arg1) {
	            // TODO Auto-generated method stub
	            return 0;
	        }
	}
	
	
	Como utilizamos o parâmetro Conta na interface Comparator, nosso método compare() trabalha 
	com o mesmo, afinal, nosso objetivo é comparar duas contas.

	O objetivo deste método é poder determinar quando que uma conta é maior, ou menor, 
	do que outra - e qual o critério de avaliação. Quanto a este último, quem deve defini-lo 
	somos nós, os desenvolvedores. Podemos, por exemplo, determinar que o saldo será o critério 
	determinante, ou o titular, o número da agência, enfim, o que acharmos mais conveniente.
	
	
	O funcionamento do método compare() terá um funcionamento similar ao do equals(). 
	Teremos um retorno 0 somente se o número das contas forem idênticos, se o número da 
	conta c1 for inferior ao da c2, nosso retorno será um valor negativo.
	
	class NumeroDaContaComparator implements Comparator<Conta> {

	        @Override
	        public int compare(Conta c1, Conta c2) {
	
	                if(c1.getNumero() < c2.getNumero()) {
	                    return -1;
	                }
	
	            return 0;
	        }
	}

	
	Evidentemente que, se c1 é maior que c2, então devemos ter um resultado positivo. 
	Assim, criaremos um segundo if que reflita esta regra:
	
	class NumeroDaContaComparator implements Comparator<Conta> {

	        @Override
	        public int compare(Conta c1, Conta c2) {
	
	                if(c1.getNumero() < c2.getNumero()) {
	                    return -1;
	                }
	
	                if(c1.getNumero() > c2.getNumero()) {
	                    return 1;
	                }
	
	            return 0;
	        }
	}
	
	
	próximo passo será criar uma instância da classe NumeroDaContaComparator, para isso, 
	criaremos um objeto desta classe:
	
	//Código omitido

	public class Teste {
	
	        public static void main(String[] args) {
	
	        //Código omitido
	
	        List<Conta> lista = new ArrayList<>();
	        lista.add(cc1);
	        lista.add(cc2);
	        lista.add(cc3);
	        lista.add(cc4);
	
	        NumeroDaContaComparator comparator = new NumeroDaContaComparator();
	
	        lista.sort(comparator);
	
	        }
	
	}
	
	class NumeroDaContaComparator implements Comparator<Conta> {
	
	        @Override
	        public int compare(Conta c1, Conta c2) {
	
	                if(c1.getNumero() < c2.getNumero()) {
	                    return -1;
	                }
	
	                if(c1.getNumero() > c2.getNumero()) {
	                    return 1;
	                }
	
	            return 0;
	        }
	}
	
	Em seguida, testaremos nosso código. Para isso, criaremos dois laços, 
	um antes e outro depois da comparação.
	
	//Código omitido

	public class Teste {
	
	        public static void main(String[] args) {
	
	        //Código omitido
	
	        List<Conta> lista = new ArrayList<>();
	        lista.add(cc1);
	        lista.add(cc2);
	        lista.add(cc3);
	        lista.add(cc4);
	
	        foreach (Conta conta : lista) {
	            System.out.println(conta);
	        }
	
	        NumeroDaContaComparator comparator = new NumeroDaContaComparator();
	
	        System.out.println("---------");
	
	        lista.sort(comparator);
	
	        for (Conta conta : lista) {
	            System.out.println(conta);
	        }
	
	    }
	
	}
	
	class NumeroDaContaComparator implements Comparator<Conta> {
	
	        @Override
	        public int compare(Conta c1, Conta c2) {
	
	                if(c1.getNumero() < c2.getNumero()) {
	                    return -1;
	                }
	
	                if(c1.getNumero() > c2.getNumero()) {
	                    return 1;
	                }
	
	            return 0;
	        }
	}
	
	
	
	Aula 03 - A Orderm Natural
	
	
	Primeiro, como podemos simplificar o método compare(), da NumeroDaContaComparator?
	
	class NumeroDaContaComparator implements Comparator<Conta> {

	        @Override
	        public int compare(Conta c1, Conta c2) {
	
	                if(c1.getNumero() < c2.getNumero()) {
	                    return -1;
	                }
	
	                if(c1.getNumero() > c2.getNumero()) {
	                    return 1;
	                }
	
	            return 0;
	        }
	}
	
	
	
	Na regra, temos um retorno negativo caso o valor da conta c1seja inferior ao da c2, 
	e positivo se c1 for maior que c2. Caso sejam iguais, o retorno é 0. Entretanto, 
	se escrevermos da seguinte forma:
	
	
	return c1.getNumero() - c2.getNumero();
	
	
	A regra permanece a mesma, apenas alteramos o modo de escrevê-la. 
	Sempre que tivermos um critério baseado em dados numéricos, é possível 
	simplifica-lo.

	Há ainda outra forma de escrevermos esta mesma regra. Assim como a String, 
	o Integer também tem implementado um método de comparação, assim, poderíamos 
	escrever o seguinte - comentando também a última linha de código que inserimos:
	
	
	class NumeroDaContaComparator implements Comparator<Conta> {

        @Override
        public int compare(Conta c1, Conta c2) {

               return Integer.compare(c1.getNumero(), c2.getNumero());

		//                        return c1.getNumero() - c2.getNumero();
		//
		//                if(c1.getNumero() < c2.getNumero()) {
		//                    return -1;
		//                }
		//
		//                if(c1.getNumero() > c2.getNumero()) {
		//                    return 1;
		//                }
		//
		//            return 0;
		        }
	}
	
	ArrayList, LinkedList e Vector:
	
	ArrayList: Lista implementada como um Array que é dimensionado dinamicamente, 
	ou sejam sempre que é necessárioo seu tamanho aumenta em 50% do tamanho da lista, 
	significa que se caso uma lista de tamanho igual a 10 e ela "encher", seu tamanho
	aumentará para 15 de maneira automatica.
	
	Além disso a ArrayList, premite que seus elementos sejam acessados diretamente
	pelos métodos get() e set(), e adicionados através de add() e removidos
	atrvés do remove().
	
	
	Vector: Do ponto de vista da API, ou seja, da forma como é utilizado, 
	o Vector e o ArrayList são muito similares, podemos arriscar até em 
	dizer: iguais. Se você conhece a fundo o conceito de Vector e ArrayList
	usará ambos como se fossem o mesmo, sem sentir nenhumka difereça, 
	veja na listagem 2 um exemplo disso:
	
	import java.util.Iterator;
	import java.util.Vector;
	
	public class Principal {
	
		public static void main(String args[]) {
	
			Vector al = new Vector();
			al.add(3);
			al.add(2);
			al.add(1);
			al.add(4);
			al.add(5);
			al.add(6);
			al.add(6);
	
			Iterator iter1 = al.iterator();
			while(iter1.hasNext()){
			        System.out.println(iter1.next());
			}
	
			System.out.println(al.get(2));
	
		}
	
	}
	
	
	-> Vector é sincronizado e ArrayList não, ou seja, se você possui uma 
	aplicação que precisa ser thread-safe em determinado ponto, use Vector e 
	você estará garantido
	-> Outro ponto importante é a alocação dinâmica do Vector, que é diferente
	do Arralist. O Vector quando se "enche", aumenta o dobro, ou seja, 
	se você tem uma lista de 10 elementos cheia, essa lista aumentará para 20, 
	com 10 posições vazias. Se caso você precisar aumentar a quantidade de 
	elementos com frequência, então o ideal é usar o Vector que aumenta
	o dobro e ficará com muito mais espaço do que o ArrayList, que precisará
	ficar aumentando com mais frequencia, compprometendo assim a performance 
	da sua aplicação.
	
	
	
	LinkedList:
	
	import java.util.Iterator;
	import java.util.LinkedList;
	
	
	
	public class Principal {
	
		public static void main(String args[]) {
	
			LinkedList ll = new LinkedList();
			ll.add(3);
			ll.add(2);
			ll.add(1);
			ll.add(4);
			ll.add(5);
			ll.add(6);
			ll.add(6);
	
			Iterator iter2 = ll.iterator();
			while(iter2.hasNext()){
				System.out.println(iter2.next());
			}
	
		}
	
	}
	
	praticamente identico a ArrayList, porém, este tipo de lista
	implementa um "double linked list", ou seja, 
	uma lista duplamente "linkada". A sua principal diferença entre o ArrayList
	é na performance entre os métodos add, remove, get e set.
	
	este tipo de lista possui melhor performance nos métodos
	add e remove, do que os métodos add e remove do ArrayList, em compensação 
	seus métodos get e set possuem uma performance pior do que os do ArrayList.
	Comparação entre a complexidade de cada método do ArrayList e LinkedList:
	
	-> get(int index): LinkedList possui O(n) e ArrayList possui O(1)
	-> add(E element): LinkedList possui O(1) e ArrayList possui O(n) no pior caso, 
	visto que o array será redimensionado e copiado para um novo array.
	->add(int index, E element): LinkedList possui O(n) e ArrayList possui O(n) 
	no pior caso
	-> remove(int index): LinkedList possui O(n) e ArrayList possui O(n-index), 
	se remover o último elemento então fica O(1)
	
	Perceba então que a principal diferença está na performance.
	
	
	
	
	Ordenando listas:
	
	A classe java.util.Collections é um conjunto de métodos estáticos
	auxiliares as coleções. Temos o método sort:
	
	-> Collections.sort(aulas);
	
	import java.util.List;
	import java.util.ArrayList;
	import java.util.Collections;
	
	class TestandoListas {
	
	    public static void main(String[] args) {
	
	        String aula1 = "Modelando a classe Aula";
	        String aula2 = "Conhecendo mais de listas";
	        String aula3 = "Trabalhando com Cursos e Sets";
	
	        ArrayList<String> aulas = new ArrayList<>();
	        aulas.add(aula1);
	        aulas.add(aula2);
	        aulas.add(aula3);        
	
	        System.out.println(aulas);
	
	        Collections.sort(aulas);
	        System.out.println("Depois de ordenado:");
	        System.out.println(aulas);        
	    }
	}
	
	
	documentação: 
	https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo-java.lang.String-
	
	Metodos Collections:
	https://www.devmedia.com.br/conheca-a-api-java-collections/31995#:~:text=O%20m%C3%A9todo%20Rotate%20da%20classe,que%20os%20elementos%20ser%C3%A3o%20deslocados.
	
	
	
	
	
	
	
	
	
	
	
	