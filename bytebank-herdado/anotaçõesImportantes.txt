Java Polimorfismo: Entenda herança e interfaces.

Aula 06 - Capítulo 01

sem a questão da herança, foi identificado alguns problemas em trabalhar com todas as funcionalidades em uma 
única classe.

nesse projeto, temos diferentes tipos de funcionários, cada um com usas especificações, ou seja, 
termos cada uma delas em um só lugar tornará o programa muito díficil de manter.



se pararmos para analisar, o gerente também é um funcionário, desta forma, 
para o código em si, ficar menos verboso e mais clean, podemos 
inidcar ao Java que o Gerente irá herdar tudo de Funcionário

Na sintaxe do Java, a herança é expressada pela palavra extends...

Ex: public class Gerente extends Funcionario {
		
	}

	
Como Gerente é um Funcionário, podemos utilizar, de forma direta, o método setNome - que origina da 
classe Funcionario. O mesmo vale para Cpf e Salario.


public class TesteGerente {
	
	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("02589645726");
		g1.setSalario(5500.00);
		
		
		System.out.println(g1.getNome());
		System.out.println(g1.getCpf());
		System.out.println(g1.getSalario());
		
		boolean autenticou = g1.autentica(2222);
		
		/*
			o método autenticou foi criado 
			ao executar esse codigo pela primeira vez, resultará em false...
			pois, a senha padrão do Gerente é 0, já que não inicializamos este atributo com nenhum valor
			em particular.
			 
		*/
		System.out.println(autenticou);
		
				
	}
	
}


O gerente conta também com um método autentica, que é particular e não consta em Funcionário....
esse método foi criado na classe Gerente

Inicialmente o valor booelan volsa false, pois,  o padrão do Gerente é 0, já que inicializamos 
este atributo com nenhum valor em particular.


para efetuar um teste, foi criado um método setSanha() na classe Gerente..

ao retornar a classe TesteGerente, chamando o método setSenha()...

é possível observar que no próprio menu do Eclipse surge algumas sugestões, 
que enquanto todos os outros otiginam de Funcionario, este método
vem da classe Gerente.


Nessa aula começamos a falar sobre a herança e aprendemos:

-> quais problemas a herança pode resolver
-> como usar herança no Java através de palavra chave extends
-> ao herdar, a classe filha ganha todas as características (atributos) e todas as funcionalidades (métodos) da classe mãe
-> conhecemos o primeiro benefício da herança: Reutilização do código




Aula 01 - Capítulo 02 - Herança no diagrama de classes

Somente relembrando, foi criada uma classe extra, para respresentar o gerente. Nela, temos todo o código específico para representá-lo, 
ou seja, uma senha, que é atribuído a mais em relação ao Funcionário, e dois métodos, sem contar com o Bonificação, que ganhará especificação, 
em relação ao que já existe para o Funcionário.


Para não repetirmos código, utilizamos conceitos de herança, representado pela palavra extends:

public class Gerente extends Funcionario {
	
	//codigo omitido
	
}


com o trecho de código acima, estamos querendo dizer que o Gerente possui os mesmos atributos e métodos que o Funcionario.


É costume chamar esta classe Funcionario de classe mãe ou classe pai ou simplesmente, que ela está acima de outra com a qual estivermos 
trabalhando.

no caso, a classe Gerente seria a classe filha.

 

agora com toda essa parte de nomenclatura...

Vamos criar o primeiro gerente

Gerente g1 = new Gerente();

O que acontece interiormente, é a criação de um objeto, com atributos baseados na hierarquia estabelecida.



Representando objeto Gerente

nome = null

cpf = null

salario = 0.0

senha = 0



Ou seja, se pararmos para entender, todos os atributos de Funcionario, mais o seu especifico, que é a senha, foram apresentados.
É esta a ideia de herança.

Ao utilizar a referencia g1, é possível chamarmos todos os métodos da hierarquia, ou seja, não só aquelas definidas na própria 
classe Gerente, como também aqueles presentes na classe Funcionario.

Ex.:

g1.setNome("Brunno");

o método setNome, so funciona, pois, existe um atributo nome, que por 'de baixo dos panos'... 

ficara assim:


Representando objeto Gerente

nome = Brunno

cpf = null

salario = 0.0

senha = 0




Aula 02 - Capítulo 02 - Reescrita de métodos


so relembrando o objetivo de getBonificacao(), era implementarmos na classe Funcionario, um método que calculasse uma 
bonificação de modo padrão para todos os funcionários, entretanto, foi verificado que não condiz com a realidade de negócio da empresa, 
uma vez que o gerente terá uma bonificação diferenciada dos demais funcionários da empresa.


porém, se olharmos dentro da classe Funcionario, veremos que ao tentar acessar o atributoi salario, não será possivel,
pois, o mesmo é private, onde, este termo é um modificador de visibilidade, que permite que esta informação seja vísivel somente dentro
da classe em si.

Acontece que ao utilizar o método getBonificacao() na classe Gerente estamos querendo acessá-lá externamente, por isso o
erro de compilação apareceu.

uma possível solução, seria trocar este modificador de private para public, porém, isso não seria uma boa prática de 
programação.

Para solucionar essa questão, veremos que há outro modificador que está entre o private e o public, ou seja, ele nem é visivel
somente em determinada classe, e tampouco pode ser visualizado por todos. Este modificador se chama protected.


Desta forma, as informações ali contidas serão públicas apenas para si e para os filhos, as demais classes, não. 

public class Funcionario {

	private String nome;
	private String cpf;
	protected double salario;

	//codigo omitido

}

se caso fazer tanto teste para somente funcionario e tambem para o gerente, ambos a bonificação passará
a funcionar, através da ajuda do terceiro modificador de visibilidades que passamos a utilizar, no caso, o protected, 
que fica entre o private e o public, ainda não foi possivel visualizar , isto de forma clara poque nossas classes
ainda não estão bem subdivididas, por enquanto, elas estão armazenadas em um único pacote.

 o protected foi feito para liberar o acesso ao atributo para os filhos, e deixar privado para todas as outras classes. Ou seja, quem não é um Funcionário
 não verá o salário.
 
 
 
 Olhando outro ponto agora, como programador, ao utilizarmos o this., no caso, do this.salario, no código, somos levados a olhar para os 
 atributos, pois, pensamentos que o atributo salario, automaticamente pertence a esta classe.
 
 o this, além de guardar a referência para mexermos nos atributos do objeto, para desenvolvedor, significa que o atributo deve estar definido
 nesta classe. Entretanto, neste caso o salario não esta definido na classe Gerente, e sim na classe mão ou super classe, Funcionario.
 
 para mostrarmos que o atributo salario, vem da super classe, há outra palavra reservada que pode ser utilizada, que é a super:
 
 public double getBonificacao() {
 	return super.salario;
 }


sendo assim, o desenvolvedor, saberá que é preciso subir na hierarquia para encontrar este atributo,k já que ele 
não está definido nesta classe. 
Se colocarmos super em algo definido dentro da própria classe, o Eclipse apontará um erro de compilação, ja que neste caso
ele procurará na classe acima e não encontrará o atributo.

porém, na classe Funcionário, temos nosso método getBonificação() que é público, devolve um double, e não recebe parâmetros:

//código omitido

public double getBonificacao() {
	return this.salario * 0.1;
}

//codigo omitido


Está prática, é chamado de assinatura de método. Se olharmos para a classe Gerente, veremos que lá temos a mesma assinatura do método, 
o que chamamos de reescrita.


Já entramos mais a fundo na herança. Aprendemos:

 - que classe mãe é chamada de super ou base class
 - que a classe filha também é chamada de sub class
 - como aumentar a visibilidade de um membro (atributo, método) através do protected
 - como acessar ou chamar um membro (atributo, método) através do super
 - como redefinir um método através da sobrescrita



Aula 01 - Capítulo 03 - Reescrita de métodos


Até este ponto, podemos ver uma importante parte do conceito de herança, que tratou da reutilização de código. 
Como uma boa prática de programação, não queremos repetir código e para isso, podemos estender a classe, utilizando 
extends -> Gerente estende a classe Funcionario

Isso significa também dizer que Gerente herdou todos os atributos e características da classe Funcionário.

para exemplificar, a próxima parte, criaremos uma nova classe:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
	
	}

}


desta forma, podemos chamar qualquer um cod métodos definidos, como o setNome() e podemos recuperar
o nome com g1.getNome();



public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}

ao executar, funcionará normalmente, imprimindo o nome do Gerente.

Até o momento, quando criamos um novo objeto, utilizamos o lado direito com o new, para então chamarmos o construtor
com o nome da classe, por exemplo, no caso acima, nem Gerente().
Enquanto isso, no lado esquerdo temos o tipo da variável, seguido pelo nome, no caso Gerente g1.

Entretanto, como todo Gerente é também um funcionário, é possível declarar a variável de um tipo mais genérico,
ou seja, do tipo Funcionario:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Funcionario g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}


Agora a variável é to tipo Funcionario, ela não é mais do tipo Gerente, e sim do tipo mais genérico.Nosso código continua compilando e se executarmos
novamente, teremos o mesmo resultado...

será que o contrário tambem funciona?
Resposta: Não!!!

pois todo Gerente é um funcionário, mas nem todo funcionário é um Gerente.


se colocarmos ao contrario: 

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Funcioario(); //criação de um novo gerente.
		
		//codigo omitido
		
		g1.autentica(2222);
		
		
	}

}



O compilador vai indicar que isso não funciona, mas porque? 
Se criamos um objeto do tipo Gerente?
Para o compilador, isso não importa. 

O que ele faz é analisar o tipo da referência, ou seja, g1 que é do tipo Funcionario.

Como esta classe não tem o método autentica, o compilador indica a presença de um erro.

O que pode variar, é o tipo da referência, "aquilo" que está localizado à esquerda do nome do objeto, no caso
é o Funcionario,mas como vimos, poderíamos ter definido como Gerente também, que funcionária.

A isso, damos o nome de polimorfismo, temos um mesmo objeto do tipo Gerente, mas há duas formas possíveis de chegarmos 
a este objeto, dois tipos diferentes de referência. 



Aula 02 - Capítulo 03 - Aplicando polimorfismo

anteriormente falavamos sobre o polimorfismo, onde vimos que se trata de um objeto que pode ser referenciado por uma referência do mesmo tipo, ou genérica.
Ou seja, se temos um objeto Gerente(), a referência pode ser tanto do tipo Gerente, quanto do tipo Funcionario.


para fazer o controle de bonificação, teremos uma classe chamada ControleBonificacao. Ela terá um método público chamado registra:

public class ControleBonificacao {

        public void registra() {

        }
}



nesta classe queremos tambem retornar a soma de todas as bonificações, por isso criaremos um método chamado getTotal():

public class ControleBonificacao {

        public void registra() {

        }
        
        public double getTotal() {
        	return total;
        }
}


retornamos na classe TesteReferencia e imprimimos o total:

public class TesteReferencias {

        public static void main(String[] args) {

                Gerente g1 = new Gerente();
                g1.setNome("Brunno");
                g1.setSalario(3000.0);

                ControleBonificacao controle = new ControleBonificacao();
                controle.registra(g1);

                System.out.println("Bonificação Geral: " + controle.getTotal());

        }
}


ao executar, ira aparecer somente o total, indicando que funcionou. Como temos somente um gerente, 
so aparecerá a bonificação do Gerente.



em seguida se quisermos criar mais um funcionario, do tipo Funcionario, com salário de R$2000,00 e que também será registrado e
tambem mais um funcionario, sue será o Editor de video, ele tambem estende a classe Funcionario e sua bonificação é o 
valor padrão acrescido de  R$100,00

so criarmos a classe: 

public class EditorVideo extends Funcionario {

        public double getBonificacao() {
                return super.getBonificacao() + 100;

        }
}


Para que possamos registralos, não será preciso criar outro metodo dentro da classe ControleBonoficacao, pois, 
queremos ter apenas um método que sirva para os funcionários de forma geral:


public class ControleBonificacao {

	private double total;
	
	public void registra(Funcionario f) {
		double boni = f.getBonificacao();
		this.total = this.total + boni;
	}

	public double getTotal() {
		return total;
	}
	
}


Aula 06 - Capítulo 03 - Resumo herança

 

Existem duas características principais da herança:
 - reutilização de código
 - Polimorfismo
 
 
 
 Reutilização de código, é conceituada como extensão da classe, com a palavra extends, isso faz com que a classe filha 
 herde automaticamente todos os dados, atributos e funcionalidades dos métodos
 
 no meu código, a Gerente é baseada em todos os atributos da hierarquia.
 
 quando criamos um gerente, ele terá uma senha, porque isso está definido dentro da classe Gerente. Além disso, 
 ele também terá um nome, um cpf e um salário, todos estes são atributos da classe Funcionario. O mesmo vale para os métodos, 
 como getters e setters e getBonificacao(), incluindo os métodos específicos de Gerente que terão preferência em relação
 aos mais genéricos.
 
 ja o Polimorfismo é mais complexo
 Por exemplo a hierarquia da classe Funcionario, em que ela é mão das classes Gerente e EditorVideo.
 
 Quando criamos um Gerente, temos um objeto do tipo Gerente:
 
 Gerente gerente = new Gerente();
 
 o objeto em si nunca muda o tipo. Uma vez que ele é criado com o tipo Gerente, terá sempre este tipo. O mesmo vale para o EditorVideo:
 
 EditorVideo ev = new EditorVideo();
 
 no caso acima, o tipo será sempre EditorVideo. O que pode variar somente é o tipo da referência -> Isto é polimorfismo!
 
 antes o tipo da referência era sempre igual ao tipo do objeto, com o polimorfismo, aprendemos que a referência pode ser de um 
 tipo mais genérico. No nosso exemplo, esta classe mais genérica é Funcionario:
 
 Funcionario gerente = new Gerente();
 Funcionario editor = new EditorVideo();
 
 isso so funciona, porque todo Gerente e EditorVideo são Funcionários...
 
 
 Ao termos uma referência genérica, do tipo Funcionário, que aponta para objetos de tipos diferentes. É possível comunicar com os 
 tipos diferentes de objetos, apartir de uma mesma referência genérica. Daí surge a vantagem do polimorfismo, como a seguir:
 
 
 public class ControleBonificacao {
 	private double soma;
 	
 	public void registra(Funcionario f){
 		double boni = f.getBonificacao();
 		this.soma = this.soma + boni;
 	}
 	
 	public double getSoma() {
 		return soma;
 	}
 	
 }
 
 
 a referência genérica, neste caso Funcionario, pode apontar para tipos de objetos diferentes, desde que pertençam à mesma 
 hierarquia. Pode apontar tanto para um Gerente, quanto para um EditorVideo, ou ainda para um Funcionario.
 
 Por isso, não temos como saber, somente apartir desta classe, qual objeto getBonificacao() será chamado. 
 Para o Gerente há um método especifico para o cálculo da bonificação, e por ser especifico, é ele quem 
 será chamado, isso tambem se aplica parar EditorVideo.
 
 Criando um novo tipo de Funcionario ou seja, uma nova classe.
 
 public class Designer extends Funcionario {
 	
 	public double getBonificacao(){
 		System.out.println("Chamando metodo de Bonoificação do Designer");
 		return 200;
 	}
 	
 }
 
 
 Lembrando que Designer também é um funcionário:
 
 
 
 
public class TesteReferencias {

	public static void main(String[] args) {
		
		//codigo omitido
		
		Designer d = new Designer();
		d.setNome("Gabriela");
		d.setSalario(3200.0);
		
		ControleBonificacao controle = new ControleBonificacao();
		
		System.out.println("Nome: " + g1.getNome());
		System.out.println("Salario: " + g1.getSalario());
		System.out.println("Bonificacao: " + g1.getBonificacao());
		controle.registra(g1);
		System.out.println();
		System.out.println("Nome: " + f.getNome());
		System.out.println("Salario: " + f.getSalario());
		System.out.println("Bonificacao: " + f.getBonificacao());
		controle.registra(f);
		System.out.println();
		System.out.println("Nome: " + ev.getNome());
		System.out.println("Salario: " + ev.getSalario());
		System.out.println("Bonificacao: " + ev.getBonificacao());
		controle.registra(ev);
		System.out.println();
		System.out.println("Nome: " + d.getNome());
		System.out.println("Salario: " + d.getSalario());
		System.out.println("Bonificacao: " + d.getBonificacao());
		controle.registra(d);
		System.out.println();
		System.out.println("Bonificação Geral: " + controle.getTotal());

	}

}
 
 
 
 Até o momento tudo esta compilando e funcionando e não foi necessário alterar o método apenas
 para criarmos um novo tipo de funcionario, essa é a vantagem do polimorfismo - é possível criar
 um código bem mais genérico que depende de um tipo genérico, criar outros tipos em nosso código, 
 e tudo continua funcionando. 
 
 
 Nessa aula aprendemos que:

 - objetos não mudam de tipo;
 - a referência pode mudar, e aí entra o polimorfismo;
 - o polimorfismo permite usar referências mais genéricas para a comunicação com um objeto;
 - o uso de referências mais genéricas permite desacoplar sistemas.
 
 
 
 
 
 
 
 
 
Aula 01 - Capítulo 04 - Herança e construtores

Utilizando o exemplo da classe Conta, com duas filhas agora, a ContaCorrente e a ContaPoupanca, ou seja,
tipos mais especificos de uma conta. 

o objetivo em si, é criar dois tipos mais específicos de contas. Se pensarmos em um banco, temos contas-poupancas
ou conta-corrente.


criando classe ContaCorrente, ja extendendo as informações da classe mãe..

public class ContaCorrente extends Conta {
	
}


estamos falando sobre reutilização de código, porém, da forma como colocamos acima, não irá compilar
qual seria o problema?

Estendendo a Conta os atributos e métodos são herdados, entretanto, os construtores não são herdados.
Os construtores pertencem somente a sua própria classe.

na classe conta, tem seu construtor especifico:

//Código omitido

    public Conta(int agencia, int numero){
        Conta.total++;
        System.out.println("O total de contas é " + Conta.total);
        this.agencia = agencia;
        this.numero = numero;
        this.saldo = 100;
        System.out.println("Estou criando uma conta " + this.numero);
    }

//Código omitido


porém, ela não é automaticamente dísponivel para a classe filha ContaCorrente. 
Por isso, temos que escrever, na classe ContaCorrente, nosso proprio construtor:

public class ContaCorrente extends Conta {
	
	public ContaCorrente() {
		
	}
	
} 


ainda acontece o erro de compilação, pois, como estamos utilizando 
o construtor padrão, ainda esta tentando chamar o construtor padrão
da classe mãe.

para contornarmos essa situação, o que podemos fazer utilizar a palavra reservada
super(), que sempre fará com que o Java busque o padrao, mas podemos utilizá-lo 
para chamar um construtor especifico

na classe ContaCorrente(), definiremos parâmetros para o construtor: 

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero) {
		super(agencia,numero);
	}
	
}


e para a ContaPoupanca, basta repetir o mesmo processo de criação:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia,numero);
	}
	
}




Aula 03 - Capítulo 04 - Conta Corrente e Poupança

Para manipular nossas classes ContaPoupanca e ContaCorrente, 
primeiro iremos criar uma classe para teste:

public class TesteContas {
	
	public static void main(String[] args) {
	
	}
	
}


agora, criando um objeto ContCorrente e um ContaPoupanca:

public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		
	}
	
}


importante notar que o método deposita(), não está pŕesente na classe ContaCorrente e nem na 
ContaPoupanca, estamos reutilizando os métodos da classe Conta.



fazendo mais umn exemplo..
temos a questão de transferir dinheiro, para isso, utilizamos o método transfere():


public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		cc.transfere(10.0, cp); //transferindo 10 reais da cc para a cp
		
		//para imprimir no caso o saldo
		System.out.println("CC: " + cc.getSaldo());
		System.out.println("CP: " + cp.getSaldo());
		
		
	}
	
}

ao observarmos, ganhamos todas as funcionalidades da classe mãe, Conta.

mas aonde eu posso obervar o polimorfismo?

no método transfere, por exemplo:

public class Conta {

//Código omitido

public boolean transfere(double valor, Conta destino) {

    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Restante do código omitido


Estamos recebendo como parâmetro a Conta, ou seja, o tipo genérico, não sabemos ainda se é uma 
ContaCorrente ou ContaPoupanca.
Este código funciona por causa do polimorfismo, temos referência do tipo genérico, que pode 
apontar para qualquer um mais específico, no caso, tanto ContaCorrente, quanto ContaPoupanca.

alterando um pouco a regra de saque da ContaCorrente, onde ao sacar, deve ser cobrado uma taxa de R$0,20. 
Este com portamento é esoecífico da ContaCorrente.

Na classe mãe, Conta, já temos um método saca(), iremos redefinir o comportamento deste método, 
na classe ContaCorrente.


quando se reescreve um modo, em cima do mesmo aparece a palavra reservada, que recebe no caso nome 
de anotação na configuração do código Java. Esta configuração é para o compilador.


agora, queremos fazer a operação de saque e ainda, subtrair R$0,20 referentes a taxa de operação.

criando a variavel do tipo double valorASacar, que recebe o valor a ser sacado mais a taxa.

aproveitando o código criado pelo Eclipse, chamaremos o super, ou seja, subiremos na hierarquia
para chamarmos o método saca da classe Conta, a unica alteração será no vaor, que passará a ser 
valorASacar:


public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
}




no método transfere localizado na classe mãe Conta, quando utilizamos o this.saca, estamos chamando o método
saca com o valor, para destino.deposita temos a mesma coisa,  é feita uma referência, o this é uma referência.

public class Conta {

//Código omitido

public boolean transfere(double valor, conta destino) {
    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Código omitido



Na classe TesteContas, quan do utilizamos o cc.transfere, o this tem o mesmo valor de cc, ou seja, o this é a seta
que aponta para um objeto do tipo ContaCorrente. 

Desta forma, estaremos chamando o método mais específico, ou seja, o da ContaCorrentem por isso, 
ao executarmos a classe TesteContasjá obtivemos o resultado esperado.



Aula 07 - Capítulo 04 - O que aprendemos?

Nessa aula, vimos:

 - Conceitos de herança, construtores e polimorfismo
 - A utilização da anotação @Override
 - Construtores não são herdados
 - Um construtor da classe mãe pode ser chamado através do super()




Aula 01 - Capítulo 05 - Classes Abstratas


Utilizando a classe Funcionario novamente, voltaremos ao projeto
bytebank-herdado, que tem as classes Funcionario e Gerente, seguindo hierarquia que tínhamos, onde 
o Funcionario é a super classe.

os filhos desta classe são Gerente, EditorVIdeo e Designer.

em uma empresa de verdade não existe o cargo Funcionario, porém, não podemos apagar simplesmente 
a classe Funcionario, pois, muita coisa pararia de funcionar, pois o conceito comum
de Funcionario é importante para nosso código, para resolver isso
abriremos a classe Funcionario e queremos evitar de alguma forma a existência de um funcionário 
desta forma, sem nenhum cargo específico. Para que isso aconteça, o new Funcionario() não deveria
funcionar, pois, estaríamos criando algo que é só um funcionário.

No exemplo, "funcionário" é um conceito, algo abstrato, o concreto seria, gerente, programador,
designer, editor de vídeo e por ai vai, note que todos são funcionários, mas não apenas isso.

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//codigo omitido
	
}


A palavra abstract sempre estará relacionado com herança

antes no nossa classe TesteReferencias estavamos fazendo um new Funcionario();
isso gerará um erro de compilação, pois, não é mais possível criar um funcionario. 
o new indica criação de algo concreto, como a classe Funcionario agora 
é abstrata, será indicado como erro de compilação.


podemos simplesmente tirar este trecho de código ou então criar um 
Gerente, Designer, EditorVideo... pois todos são realmente funcionarios.


na classe TesteFuncionario, temos tambem:

import java.text.DecimalFormat;

public class TesteFuncionario {
	
	public static void main(String[] args) {
		
		DecimalFormat formatador = new DecimalFormat("0.00");
		
		//Funcionario brunno = new Funcionario(); -> erro de compilação
		Funcionario brunno = new Gerente();
		
		brunno.setNome("Brunno Manduca");
		brunno.setCpf("083540479-03");
		brunno.setSalario(2500.80);
		
		System.out.println("Nome: " + brunno.getNome());
		System.out.println("CPF: " + brunno.getCpf());
		System.out.println("Salário: " + brunno.getSalario());
		System.out.println("Bonificação: " + formatador.format(brunno.getBonificacao()));
		
	}
	
}


ao trocarmos o tipo de funcionario para gerente, o codigo compila certinho, 
Ou seja, assim temos um filho concreto (Gerente), da classe Funcionario.

O mesmo conceito pode ser aplicado à estrutura de contas, temos uma conta
 poupança e outra corrente, mas não existe um tipo que seja simplesmente "conta".


Aula 03 - Capítulo 05 - Métodos abstratos


aprendemos que não é possível instanciar objetos desta classe Funcionario, pois a mesma é abstrata...

//nao pode instanciar essa classe, pq é abstrata
public abstract class Funcionario {

    private String nome;
    private String cpf;
    private double salario;

	//Código omitido
	
}

Desta forma, evitamos que seja instanciado um funcionário genérico, já que a função não existe na prática.

Os códigos das classes filhas continuam funcionando normalmente, graças ao polimorfismo, podemos fazer 
referências genéricas. Não perdemos os benefícios da herança, apenas eliminamos a possibilidade de criar um 
objeto com uma referência do tipo Funcionario, o que não faz sentido.


Agora, o chefe da empresa, decidiu que não deve existir mais uma regra padrão de bonificação para todos. 
o designer receberá R$200,00, o editor de vídeo receberá R$150,00 e o gerente um salário simples.
Não há mais uma regra padrão.

Como temos um parâmetro específico para cada funcionário, não precisamos mais do método 
getBonificacao() na classe Funcionario, por isso, ficará comentado:




public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//utilizando modificador public, para que o método tenha visibilidade pública
	/*public double getBonificacao() {
		return this.salario * 0.1;
	}*/
	
	//codigo omitido

}


Nenhuma das classes filhas utiliza o método getBonoificacao() da classe mãe, cada uma conta com seu 
próprio método específico..

Abriremos a classe ControleBonificacao:

public class ControleBonificacao {

        private double soma;

        public void registra(Funcionario f) {
            double boni = f.getBonificacao();
            this.soma = this.soma + boni;
        }

        public double getSoma() {
            return soma;
        }
}

 
E temos um problema, porque a classe Funcionario não tem mais o método getBonificacao(), 
e está apontando para um objeto f, do tipo Funcionario() - isso significa que o código não compilará.

Se apontasse para um objeto g, por exemplo, isso não aconteceria pois, na classe Gerente, 
há um método getBonificacao específico.

Ou seja, comentar o método em Funcionario não foi uma boa solução. 
Removeremos as barras para retorná-lo à forma
 

Temos que garantir que este método exista para as classes filhas. Ele precisa existir, para que o 
ControleBonificacao funcione. Entretanto, o ideal seria que ele não tivesse uma implementação, 
ou seja, que existisse da seguinte forma:

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//porém, getBonificacao() é um método concreto e para que isso funcione, declararemos ele como abstrato
	public abstract double getBonificacao();
	
}


Da mesma forma que existem classes bastratas, também existem métodos abstratos.


Na classe, significa que não é possível instanciar objetos desta classe.
No método, significa que ele não tem um corpo, ou seja, 
que não foi implementado.

como solução: O método será implementado somente nas classes filhas.


Ex.:
public class Designer extends Funcionario {

    public double getBonificacao() {
        return 200;
    }
    
}


ao colcoar o método abstrato em uma classe mãe, obrigamos os filhos a implementar 
tal método



mas há algumas outra forma de conseguir compliar esta classe, sem que utilizemos um método abstrato?
Sim, poderíamos implementar um método diretamente na classe filha, ou indicar que a própria classe filha é abstrata.

Sendo assim, aprendemos que abstract é uma palavra-chave que podemos utilizar tanto antes de 
uma classe quanto antes de um método. Apesar de seu significado estar relacionado, ele é diferente da herança.



Aula 07 - Capítulo 05 - Abstract no exemplo Conta


Falando do ponto de vista prático, não deve existir um tipo de objeto que seja somente uma conta, 
ele deve ser ou corrente ou poupança, mas não queremos apagar a classe Conta, pois, 
precisamos de seus atributos e métodos.

Para isso, manteremos esta classe, na forma abstrata.

public abstract class Conta {
	
	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido

}


assim, não será possível instanciar objetos da classe Conta;

Para ilustrar, abriremos a classe TesteContas e ao tentarmos criar um objeto do tipo Conta(), 
veremos que não é possível compilar este código.


Uma classe abstrata, pode sim ter atributos e eles serão herdados pelas classes filhas.
Ela pode sim ter construtores também, pois estes construtores não são herdados automaticamente
ou diretamente, mas podem ser chamados em classes filhas por da palavra reservada super. A classe
abstrata pode sim ter métodos também e os filhos herdam estas funcionalidades.

tudo continua de alguma forma válido, a unica vedação seria o instanciamento de objetos 
do tipo da classe abstrata. 



para praticar nos métodos, utilizaremos abstract no método deposita:

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor) {
		
		this.saldo = this.saldo + valor;
		
	}

}


assim que colocamos o abstract, gera um erro, pois não podemos colocar a classe como abstract
e manter a implementação toda ali.

Isso pode ser resolvido de duas formas:
 - tirando o abstract
 - removendo toda a implementação;
 

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor);

}



Agora as classe filhas serão obrigadas a implementar este método.



Class ContaCorrente:

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


após implementar o deposita, 
acessaremos o saldo, com o super, entretanto, ele não é visível, pois tem um modificador de visibilidade privado.
Podemos alterá-lo para protected, liberando assim o atributo para os filhos.

public abstract class Conta {

	protected double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido
	
}



fazendo o mesmo para a ContaPoupanca:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia, numero);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


Nessa aula aprendemos:

 - O que são classes abstratas
 - Para que servem classes abstratas
 - O que são métodos abstratos
 - Para que servem métodos abstratos


Aula 01 - Capítulo 06 - Mais uma classe abstrata


Revisando: 

temos a hierarquia: A classe mãe é Funcionario e as filhas são 
Gerente, EditorVIdeo e Designer.

A classe mãe é abstrata, enquanto as filhas são todas concretas. Lembrando também que a classe Gerente 
tem um método autentica(), que é do tipo boolean.

Cirando uma nova classe chamada SistemaInterno. Justamente, surgiu esta necessidade, de representarmos 
um sistema interno da empresa, que não é acessível para todos:


public class SistemaInterno {

}


Atenção, este sistema será visualizado por alguns funcionários, por isso, conterá um  método autentica() próprio, que recebe como paramêtro
um Gerente g, como base nisso o método será chamado e a senha será definida em um atributo, acima do método.
Consequentemente, esta senha será passada para o método autentica():


public class SistemaInterno {

		private int senha = 2222;

        public void autentica(Gerente g) {
            g.autentica(senha);
        }
        
}


como o metodo devolve true ou false, por isso, ele será do tipo boolean. 
Se caso autenticar, impriremos uma mensagem "Pode entrar no sistema!!", 
casp contrário, a mensagem "Senha incorreta! Não pode entrar no sistema!" será exibida.


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}



Criando agora um teste para a classe, chamada TesteSistema, 
criando um novo gerente, e o daremos uma senha. Além disso, instituiremos 
um sistema interno, passando o gerente g:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);	
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);

	}

}


Criando  um novo tipo de funcionario, para isso teremos a classe Administrador e cuja super classe será Funcionario:


public class Administrador extends FuncionarioAutenticavel {
	
	
	@Override
	public double getBonificacao() {
		return 50;
	}
	
	

}


Porém, o Administrador também terá uma senha e consequentemente, deverá ter também um método autentica, 
mas este código causará estranheza, pois estará repetindo linhas e também não resolverá o problema. 
Na classe TesteSistema, tentaremos criar um administrador, com uma senha e autenticar o mesmo:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);

	}

}

ao passamors a linha si.autentica(adm), teremos um erro de compilação, isso acontece porque na classe 
SistemaInterno só é aceito o Gerente, ou seja, teríamos que duplicar o método autentica na classe SistemaInterno, 
porém, essa constante repetição de código não é uma boa prática de programação, então deixaremos o código como está 
hoje, sem o método autentica(Administrador adm)


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


Em vez de duplicar, poderíamos inseri-lo na classe mãe Funcionario, 
o problema desta abordagem é que agora, tanto o EditorVideo e o Designer podem entrar no 
SistemaInterno, algo que não poderia acontecer..


A ídeia então é tirar o método autentica() da classe Funcionario, porque ela não se aplica a todos os funcionarios.
para solucionar este caso, teremos uma nova classe, intermediária entre a classe mãe Funcionario e as filhas autenticaveis
Administrador e Gerente.

A nova classe se chamará FuncionarioAutenticavel e as classe Administrador e Gerente estenderão esta classe.
A classe FuncionarioAutenticavel, por sua vez, estenderá a classe Funcionario.

A classe FuncionarioAutenticavel será abstrata e o método autentica() será armazenado, portanto, nessa classe.

Criando a classe FuncionarioAutenticavel e inserimos nela o método autentica():


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}



Agora, como próximo passo, temos que adequar as classes Gerente e Administrador, para estender da classe FuncionarioAutenticavel


Agora sim, as classes atendem a nossa hierarquia.
SistemaIterno ficará assim:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}

E o TesteSistema:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


assim, o código funcionará normalmente, sem necessidade de duplicar o código.





Aula 02 - Capítulo 06 - Herança multipla


O SistemaInterno não depende diretamente do Administrador nem do Gerente. 
A Abstração entre os tipos específicos de funcionários e a classe SistemaInterno é a classe autenticavel. 
Esta é a vantagem, pensando sob a ótica de design.

Criando um novo tipo de funcionário autenticavel, como por exemplo, um diretor, com uma classe Diretor, 
que estenede a classe FuncionarioAutenticavel, ou seja, podemos fazer isso sem alterar o código da classe SistemaInterno, 
nem da FuncionarioAutenticavel. Esta é a grande vantagem. Os dois lados podem evoluir separadamente.

Desde que não haja uma separação na classe FuncionarioAutenticavel, as suas classes filhas não serão afetadas. 
Esta é a vantagem do design desta abstração, do polimorfismo.

Nosso novo desafio é que não basta mais representarmos apenas funcionários em nossos sistemas, teremos que representar
também os clientes.

A classe Cliente também terá acesso ao SistemaInterno, além disso, ela também será autenticável.

o que poderíamos fazer inicialmente, é que a classe Cliente estendesse a classe FuncionarioAutenticavel, porém, 
de cara não parece ser uma boa idéia.

Criando a classe Cliente, estendendo a classe FuncionarioAutenticavel:


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	@Override
	public double getBonificacao() {
		return 0;
	}

}


Já pode se perceber um primeiro problema, pois, faz sentido o Cliente receber uma bonificação?
Pois, ele não é um funcionário, além disso, na hierarquia, esta da seguinte forma:
O cliente é um funcionário autenticável e também um funcionário.


A primeira parte da afirmação já nos soa bem estranho, porque apesar de ter a autenticação, cliente não
é um funcionário. 
Piora, quando subimos na hirerarquia e vemos que não é possível afirmarmos que o clienteé um funcionario.
Ser um funcionario, significa receber uma bonificação.

Exemplificando, criando um objeto Cliente, 

poderíamos também, ter no lado esquerdo, a classe FuncionarioAutenticavel, graça ao polimorfismo...

public class TesteFuncionario {

        public static void main(String[] args) {

        //Cliente cliente = new Cliente();
        //FuncionarioAutenticavel cliente = new Cliente();
        Funcionario cliente = new Cliente();

        //Código omitido
        
}


Isso, acaba soando estranho, pois cliente seria um funcionario ao mesmo tempo, além disso, 
seria aberta a possibilidade de definirmos um salário para o cliente, algo que também não faria sentido.

Desta forma, a classe Cliente poderia chamar métodos que não deveria ou não poderia ter permissão.

o problema ate aqui, é que o Cliente se torna um funcionario, não é muito eficiente.

Ao observar a classe FuncionarioAutenticavel percebemos que ela, na verdade tem relação somente com a 
senha e o método autentica() e não necessariamente com os funcionários, por isso, ela será renomeada
para somente Autenticavel.


Apesar dessa alteração, como não alteramos a hierarquia, o Cliente continua sendo um Funcionario, já 
que a classe Autenticavel estende Funcionario. Precisamos retirar essa relação.

Assim, retiraremos o extends

public abstract class Autenticavel {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}

ao salvar, começará a apontar vários erros em diversas classes

Em Gerente, temos um problema pois não estamos mais estendendo diretamente a classe Funcionario, por isso, 
não temos mais um getSalario.

Para o Administrador temos um erro similar, não é possível sobrescrever o método getBonificacao(), já que deixamos de herdá-lo

sendo assim, resolvemos o problema do Cliente, mas acabamos criando novos problemas.


No entanto, os métodos setNome(), setCpf() e setSalario(), todos deixaram de funcionar, porque agora o Gerente e 
o Administrador não herdam mais Funcionário.


A herança múltipla não funciona no mundo Java, por isso não adianta querer estender duas classes.
A herança múltipla não é utilizada no Java, porque poderia gerar confusão, Imaginemos que a classe Funcionario
tem uma senha e um método setSenha(), como saberemos que Autenticavel possui exatamente isto. 
Se o Gerente estender ambas, qual dos dois prevalece? Para evitar este tipo de problema, no Java, 
não há herança múltipla.


Este problema todo em si, pode ser resolvido utilizando interfaces.

No fim de tudo, o Gerente irá estender somente a classe Funcionario:




Java Polimorfismo: Entenda herança e interfaces.

Aula 06 - Capítulo 01

sem a questão da herança, foi identificado alguns problemas em trabalhar com todas as funcionalidades em uma 
única classe.

nesse projeto, temos diferentes tipos de funcionários, cada um com usas especificações, ou seja, 
termos cada uma delas em um só lugar tornará o programa muito díficil de manter.



se pararmos para analisar, o gerente também é um funcionário, desta forma, 
para o código em si, ficar menos verboso e mais clean, podemos 
inidcar ao Java que o Gerente irá herdar tudo de Funcionário

Na sintaxe do Java, a herança é expressada pela palavra extends...

Ex: public class Gerente extends Funcionario {
		
	}

	
Como Gerente é um Funcionário, podemos utilizar, de forma direta, o método setNome - que origina da 
classe Funcionario. O mesmo vale para Cpf e Salario.


public class TesteGerente {
	
	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("02589645726");
		g1.setSalario(5500.00);
		
		
		System.out.println(g1.getNome());
		System.out.println(g1.getCpf());
		System.out.println(g1.getSalario());
		
		boolean autenticou = g1.autentica(2222);
		
		/*
			o método autenticou foi criado 
			ao executar esse codigo pela primeira vez, resultará em false...
			pois, a senha padrão do Gerente é 0, já que não inicializamos este atributo com nenhum valor
			em particular.
			 
		*/
		System.out.println(autenticou);
		
				
	}
	
}


O gerente conta também com um método autentica, que é particular e não consta em Funcionário....
esse método foi criado na classe Gerente

Inicialmente o valor booelan volsa false, pois,  o padrão do Gerente é 0, já que inicializamos 
este atributo com nenhum valor em particular.


para efetuar um teste, foi criado um método setSanha() na classe Gerente..

ao retornar a classe TesteGerente, chamando o método setSenha()...

é possível observar que no próprio menu do Eclipse surge algumas sugestões, 
que enquanto todos os outros otiginam de Funcionario, este método
vem da classe Gerente.


Nessa aula começamos a falar sobre a herança e aprendemos:

-> quais problemas a herança pode resolver
-> como usar herança no Java através de palavra chave extends
-> ao herdar, a classe filha ganha todas as características (atributos) e todas as funcionalidades (métodos) da classe mãe
-> conhecemos o primeiro benefício da herança: Reutilização do código




Aula 01 - Capítulo 02 - Herança no diagrama de classes

Somente relembrando, foi criada uma classe extra, para respresentar o gerente. Nela, temos todo o código específico para representá-lo, 
ou seja, uma senha, que é atribuído a mais em relação ao Funcionário, e dois métodos, sem contar com o Bonificação, que ganhará especificação, 
em relação ao que já existe para o Funcionário.


Para não repetirmos código, utilizamos conceitos de herança, representado pela palavra extends:

public class Gerente extends Funcionario {
	
	//codigo omitido
	
}


com o trecho de código acima, estamos querendo dizer que o Gerente possui os mesmos atributos e métodos que o Funcionario.


É costume chamar esta classe Funcionario de classe mãe ou classe pai ou simplesmente, que ela está acima de outra com a qual estivermos 
trabalhando.

no caso, a classe Gerente seria a classe filha.

 

agora com toda essa parte de nomenclatura...

Vamos criar o primeiro gerente

Gerente g1 = new Gerente();

O que acontece interiormente, é a criação de um objeto, com atributos baseados na hierarquia estabelecida.



Representando objeto Gerente

nome = null

cpf = null

salario = 0.0

senha = 0



Ou seja, se pararmos para entender, todos os atributos de Funcionario, mais o seu especifico, que é a senha, foram apresentados.
É esta a ideia de herança.

Ao utilizar a referencia g1, é possível chamarmos todos os métodos da hierarquia, ou seja, não só aquelas definidas na própria 
classe Gerente, como também aqueles presentes na classe Funcionario.

Ex.:

g1.setNome("Brunno");

o método setNome, so funciona, pois, existe um atributo nome, que por 'de baixo dos panos'... 

ficara assim:


Representando objeto Gerente

nome = Brunno

cpf = null

salario = 0.0

senha = 0




Aula 02 - Capítulo 02 - Reescrita de métodos


so relembrando o objetivo de getBonificacao(), era implementarmos na classe Funcionario, um método que calculasse uma 
bonificação de modo padrão para todos os funcionários, entretanto, foi verificado que não condiz com a realidade de negócio da empresa, 
uma vez que o gerente terá uma bonificação diferenciada dos demais funcionários da empresa.


porém, se olharmos dentro da classe Funcionario, veremos que ao tentar acessar o atributoi salario, não será possivel,
pois, o mesmo é private, onde, este termo é um modificador de visibilidade, que permite que esta informação seja vísivel somente dentro
da classe em si.

Acontece que ao utilizar o método getBonificacao() na classe Gerente estamos querendo acessá-lá externamente, por isso o
erro de compilação apareceu.

uma possível solução, seria trocar este modificador de private para public, porém, isso não seria uma boa prática de 
programação.

Para solucionar essa questão, veremos que há outro modificador que está entre o private e o public, ou seja, ele nem é visivel
somente em determinada classe, e tampouco pode ser visualizado por todos. Este modificador se chama protected.


Desta forma, as informações ali contidas serão públicas apenas para si e para os filhos, as demais classes, não. 

public class Funcionario {

	private String nome;
	private String cpf;
	protected double salario;

	//codigo omitido

}

se caso fazer tanto teste para somente funcionario e tambem para o gerente, ambos a bonificação passará
a funcionar, através da ajuda do terceiro modificador de visibilidades que passamos a utilizar, no caso, o protected, 
que fica entre o private e o public, ainda não foi possivel visualizar , isto de forma clara poque nossas classes
ainda não estão bem subdivididas, por enquanto, elas estão armazenadas em um único pacote.

 o protected foi feito para liberar o acesso ao atributo para os filhos, e deixar privado para todas as outras classes. Ou seja, quem não é um Funcionário
 não verá o salário.
 
 
 
 Olhando outro ponto agora, como programador, ao utilizarmos o this., no caso, do this.salario, no código, somos levados a olhar para os 
 atributos, pois, pensamentos que o atributo salario, automaticamente pertence a esta classe.
 
 o this, além de guardar a referência para mexermos nos atributos do objeto, para desenvolvedor, significa que o atributo deve estar definido
 nesta classe. Entretanto, neste caso o salario não esta definido na classe Gerente, e sim na classe mão ou super classe, Funcionario.
 
 para mostrarmos que o atributo salario, vem da super classe, há outra palavra reservada que pode ser utilizada, que é a super:
 
 public double getBonificacao() {
 	return super.salario;
 }


sendo assim, o desenvolvedor, saberá que é preciso subir na hierarquia para encontrar este atributo,k já que ele 
não está definido nesta classe. 
Se colocarmos super em algo definido dentro da própria classe, o Eclipse apontará um erro de compilação, ja que neste caso
ele procurará na classe acima e não encontrará o atributo.

porém, na classe Funcionário, temos nosso método getBonificação() que é público, devolve um double, e não recebe parâmetros:

//código omitido

public double getBonificacao() {
	return this.salario * 0.1;
}

//codigo omitido


Está prática, é chamado de assinatura de método. Se olharmos para a classe Gerente, veremos que lá temos a mesma assinatura do método, 
o que chamamos de reescrita.


Já entramos mais a fundo na herança. Aprendemos:

 - que classe mãe é chamada de super ou base class
 - que a classe filha também é chamada de sub class
 - como aumentar a visibilidade de um membro (atributo, método) através do protected
 - como acessar ou chamar um membro (atributo, método) através do super
 - como redefinir um método através da sobrescrita



Aula 01 - Capítulo 03 - Reescrita de métodos


Até este ponto, podemos ver uma importante parte do conceito de herança, que tratou da reutilização de código. 
Como uma boa prática de programação, não queremos repetir código e para isso, podemos estender a classe, utilizando 
extends -> Gerente estende a classe Funcionario

Isso significa também dizer que Gerente herdou todos os atributos e características da classe Funcionário.

para exemplificar, a próxima parte, criaremos uma nova classe:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
	
	}

}


desta forma, podemos chamar qualquer um cod métodos definidos, como o setNome() e podemos recuperar
o nome com g1.getNome();



public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}

ao executar, funcionará normalmente, imprimindo o nome do Gerente.

Até o momento, quando criamos um novo objeto, utilizamos o lado direito com o new, para então chamarmos o construtor
com o nome da classe, por exemplo, no caso acima, nem Gerente().
Enquanto isso, no lado esquerdo temos o tipo da variável, seguido pelo nome, no caso Gerente g1.

Entretanto, como todo Gerente é também um funcionário, é possível declarar a variável de um tipo mais genérico,
ou seja, do tipo Funcionario:

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Funcionario g1 = new Gerente(); //criação de um novo gerente.
		
		g1.setNome("Marcos");
		String nome = g1.getNome();
		
		System.out.println(nome);
		
	}

}


Agora a variável é to tipo Funcionario, ela não é mais do tipo Gerente, e sim do tipo mais genérico.Nosso código continua compilando e se executarmos
novamente, teremos o mesmo resultado...

será que o contrário tambem funciona?
Resposta: Não!!!

pois todo Gerente é um funcionário, mas nem todo funcionário é um Gerente.


se colocarmos ao contrario: 

public class TesteReferencias {
	
	public static void main(String[] args) {
	
		Gerente g1 = new Funcioario(); //criação de um novo gerente.
		
		//codigo omitido
		
		g1.autentica(2222);
		
		
	}

}



O compilador vai indicar que isso não funciona, mas porque? 
Se criamos um objeto do tipo Gerente?
Para o compilador, isso não importa. 

O que ele faz é analisar o tipo da referência, ou seja, g1 que é do tipo Funcionario.

Como esta classe não tem o método autentica, o compilador indica a presença de um erro.

O que pode variar, é o tipo da referência, "aquilo" que está localizado à esquerda do nome do objeto, no caso
é o Funcionario,mas como vimos, poderíamos ter definido como Gerente também, que funcionária.

A isso, damos o nome de polimorfismo, temos um mesmo objeto do tipo Gerente, mas há duas formas possíveis de chegarmos 
a este objeto, dois tipos diferentes de referência. 



Aula 02 - Capítulo 03 - Aplicando polimorfismo

anteriormente falavamos sobre o polimorfismo, onde vimos que se trata de um objeto que pode ser referenciado por uma referência do mesmo tipo, ou genérica.
Ou seja, se temos um objeto Gerente(), a referência pode ser tanto do tipo Gerente, quanto do tipo Funcionario.


para fazer o controle de bonificação, teremos uma classe chamada ControleBonificacao. Ela terá um método público chamado registra:

public class ControleBonificacao {

        public void registra() {

        }
}



nesta classe queremos tambem retornar a soma de todas as bonificações, por isso criaremos um método chamado getTotal():

public class ControleBonificacao {

        public void registra() {

        }
        
        public double getTotal() {
        	return total;
        }
}


retornamos na classe TesteReferencia e imprimimos o total:

public class TesteReferencias {

        public static void main(String[] args) {

                Gerente g1 = new Gerente();
                g1.setNome("Brunno");
                g1.setSalario(3000.0);

                ControleBonificacao controle = new ControleBonificacao();
                controle.registra(g1);

                System.out.println("Bonificação Geral: " + controle.getTotal());

        }
}


ao executar, ira aparecer somente o total, indicando que funcionou. Como temos somente um gerente, 
so aparecerá a bonificação do Gerente.



em seguida se quisermos criar mais um funcionario, do tipo Funcionario, com salário de R$2000,00 e que também será registrado e
tambem mais um funcionario, sue será o Editor de video, ele tambem estende a classe Funcionario e sua bonificação é o 
valor padrão acrescido de  R$100,00

so criarmos a classe: 

public class EditorVideo extends Funcionario {

        public double getBonificacao() {
                return super.getBonificacao() + 100;

        }
}


Para que possamos registralos, não será preciso criar outro metodo dentro da classe ControleBonoficacao, pois, 
queremos ter apenas um método que sirva para os funcionários de forma geral:


public class ControleBonificacao {

	private double total;
	
	public void registra(Funcionario f) {
		double boni = f.getBonificacao();
		this.total = this.total + boni;
	}

	public double getTotal() {
		return total;
	}
	
}


Aula 06 - Capítulo 03 - Resumo herança

 

Existem duas características principais da herança:
 - reutilização de código
 - Polimorfismo
 
 
 
 Reutilização de código, é conceituada como extensão da classe, com a palavra extends, isso faz com que a classe filha 
 herde automaticamente todos os dados, atributos e funcionalidades dos métodos
 
 no meu código, a Gerente é baseada em todos os atributos da hierarquia.
 
 quando criamos um gerente, ele terá uma senha, porque isso está definido dentro da classe Gerente. Além disso, 
 ele também terá um nome, um cpf e um salário, todos estes são atributos da classe Funcionario. O mesmo vale para os métodos, 
 como getters e setters e getBonificacao(), incluindo os métodos específicos de Gerente que terão preferência em relação
 aos mais genéricos.
 
 ja o Polimorfismo é mais complexo
 Por exemplo a hierarquia da classe Funcionario, em que ela é mão das classes Gerente e EditorVideo.
 
 Quando criamos um Gerente, temos um objeto do tipo Gerente:
 
 Gerente gerente = new Gerente();
 
 o objeto em si nunca muda o tipo. Uma vez que ele é criado com o tipo Gerente, terá sempre este tipo. O mesmo vale para o EditorVideo:
 
 EditorVideo ev = new EditorVideo();
 
 no caso acima, o tipo será sempre EditorVideo. O que pode variar somente é o tipo da referência -> Isto é polimorfismo!
 
 antes o tipo da referência era sempre igual ao tipo do objeto, com o polimorfismo, aprendemos que a referência pode ser de um 
 tipo mais genérico. No nosso exemplo, esta classe mais genérica é Funcionario:
 
 Funcionario gerente = new Gerente();
 Funcionario editor = new EditorVideo();
 
 isso so funciona, porque todo Gerente e EditorVideo são Funcionários...
 
 
 Ao termos uma referência genérica, do tipo Funcionário, que aponta para objetos de tipos diferentes. É possível comunicar com os 
 tipos diferentes de objetos, apartir de uma mesma referência genérica. Daí surge a vantagem do polimorfismo, como a seguir:
 
 
 public class ControleBonificacao {
 	private double soma;
 	
 	public void registra(Funcionario f){
 		double boni = f.getBonificacao();
 		this.soma = this.soma + boni;
 	}
 	
 	public double getSoma() {
 		return soma;
 	}
 	
 }
 
 
 a referência genérica, neste caso Funcionario, pode apontar para tipos de objetos diferentes, desde que pertençam à mesma 
 hierarquia. Pode apontar tanto para um Gerente, quanto para um EditorVideo, ou ainda para um Funcionario.
 
 Por isso, não temos como saber, somente apartir desta classe, qual objeto getBonificacao() será chamado. 
 Para o Gerente há um método especifico para o cálculo da bonificação, e por ser especifico, é ele quem 
 será chamado, isso tambem se aplica parar EditorVideo.
 
 Criando um novo tipo de Funcionario ou seja, uma nova classe.
 
 public class Designer extends Funcionario {
 	
 	public double getBonificacao(){
 		System.out.println("Chamando metodo de Bonoificação do Designer");
 		return 200;
 	}
 	
 }
 
 
 Lembrando que Designer também é um funcionário:
 
 
 
 
public class TesteReferencias {

	public static void main(String[] args) {
		
		//codigo omitido
		
		Designer d = new Designer();
		d.setNome("Gabriela");
		d.setSalario(3200.0);
		
		ControleBonificacao controle = new ControleBonificacao();
		
		System.out.println("Nome: " + g1.getNome());
		System.out.println("Salario: " + g1.getSalario());
		System.out.println("Bonificacao: " + g1.getBonificacao());
		controle.registra(g1);
		System.out.println();
		System.out.println("Nome: " + f.getNome());
		System.out.println("Salario: " + f.getSalario());
		System.out.println("Bonificacao: " + f.getBonificacao());
		controle.registra(f);
		System.out.println();
		System.out.println("Nome: " + ev.getNome());
		System.out.println("Salario: " + ev.getSalario());
		System.out.println("Bonificacao: " + ev.getBonificacao());
		controle.registra(ev);
		System.out.println();
		System.out.println("Nome: " + d.getNome());
		System.out.println("Salario: " + d.getSalario());
		System.out.println("Bonificacao: " + d.getBonificacao());
		controle.registra(d);
		System.out.println();
		System.out.println("Bonificação Geral: " + controle.getTotal());

	}

}
 
 
 
 Até o momento tudo esta compilando e funcionando e não foi necessário alterar o método apenas
 para criarmos um novo tipo de funcionario, essa é a vantagem do polimorfismo - é possível criar
 um código bem mais genérico que depende de um tipo genérico, criar outros tipos em nosso código, 
 e tudo continua funcionando. 
 
 
 Nessa aula aprendemos que:

 - objetos não mudam de tipo;
 - a referência pode mudar, e aí entra o polimorfismo;
 - o polimorfismo permite usar referências mais genéricas para a comunicação com um objeto;
 - o uso de referências mais genéricas permite desacoplar sistemas.
 
 
 
 
 
 
 
 
 
Aula 01 - Capítulo 04 - Herança e construtores

Utilizando o exemplo da classe Conta, com duas filhas agora, a ContaCorrente e a ContaPoupanca, ou seja,
tipos mais especificos de uma conta. 

o objetivo em si, é criar dois tipos mais específicos de contas. Se pensarmos em um banco, temos contas-poupancas
ou conta-corrente.


criando classe ContaCorrente, ja extendendo as informações da classe mãe..

public class ContaCorrente extends Conta {
	
}


estamos falando sobre reutilização de código, porém, da forma como colocamos acima, não irá compilar
qual seria o problema?

Estendendo a Conta os atributos e métodos são herdados, entretanto, os construtores não são herdados.
Os construtores pertencem somente a sua própria classe.

na classe conta, tem seu construtor especifico:

//Código omitido

    public Conta(int agencia, int numero){
        Conta.total++;
        System.out.println("O total de contas é " + Conta.total);
        this.agencia = agencia;
        this.numero = numero;
        this.saldo = 100;
        System.out.println("Estou criando uma conta " + this.numero);
    }

//Código omitido


porém, ela não é automaticamente dísponivel para a classe filha ContaCorrente. 
Por isso, temos que escrever, na classe ContaCorrente, nosso proprio construtor:

public class ContaCorrente extends Conta {
	
	public ContaCorrente() {
		
	}
	
} 


ainda acontece o erro de compilação, pois, como estamos utilizando 
o construtor padrão, ainda esta tentando chamar o construtor padrão
da classe mãe.

para contornarmos essa situação, o que podemos fazer utilizar a palavra reservada
super(), que sempre fará com que o Java busque o padrao, mas podemos utilizá-lo 
para chamar um construtor especifico

na classe ContaCorrente(), definiremos parâmetros para o construtor: 

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero) {
		super(agencia,numero);
	}
	
}


e para a ContaPoupanca, basta repetir o mesmo processo de criação:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia,numero);
	}
	
}




Aula 03 - Capítulo 04 - Conta Corrente e Poupança

Para manipular nossas classes ContaPoupanca e ContaCorrente, 
primeiro iremos criar uma classe para teste:

public class TesteContas {
	
	public static void main(String[] args) {
	
	}
	
}


agora, criando um objeto ContCorrente e um ContaPoupanca:

public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		
	}
	
}


importante notar que o método deposita(), não está pŕesente na classe ContaCorrente e nem na 
ContaPoupanca, estamos reutilizando os métodos da classe Conta.



fazendo mais umn exemplo..
temos a questão de transferir dinheiro, para isso, utilizamos o método transfere():


public class TesteContas {
	
	public static void main(String[] args) {
		
		ContaCorrente cc = new ContaCorrente(111, 1234);
		cc.deposita(100.0);
		
		
		ContaPoupanca cp = new ContaPoupanca(112, 5689);
		cp.deposita(150.0);
		
		cc.transfere(10.0, cp); //transferindo 10 reais da cc para a cp
		
		//para imprimir no caso o saldo
		System.out.println("CC: " + cc.getSaldo());
		System.out.println("CP: " + cp.getSaldo());
		
		
	}
	
}

ao observarmos, ganhamos todas as funcionalidades da classe mãe, Conta.

mas aonde eu posso obervar o polimorfismo?

no método transfere, por exemplo:

public class Conta {

//Código omitido

public boolean transfere(double valor, Conta destino) {

    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Restante do código omitido


Estamos recebendo como parâmetro a Conta, ou seja, o tipo genérico, não sabemos ainda se é uma 
ContaCorrente ou ContaPoupanca.
Este código funciona por causa do polimorfismo, temos referência do tipo genérico, que pode 
apontar para qualquer um mais específico, no caso, tanto ContaCorrente, quanto ContaPoupanca.

alterando um pouco a regra de saque da ContaCorrente, onde ao sacar, deve ser cobrado uma taxa de R$0,20. 
Este com portamento é esoecífico da ContaCorrente.

Na classe mãe, Conta, já temos um método saca(), iremos redefinir o comportamento deste método, 
na classe ContaCorrente.


quando se reescreve um modo, em cima do mesmo aparece a palavra reservada, que recebe no caso nome 
de anotação na configuração do código Java. Esta configuração é para o compilador.


agora, queremos fazer a operação de saque e ainda, subtrair R$0,20 referentes a taxa de operação.

criando a variavel do tipo double valorASacar, que recebe o valor a ser sacado mais a taxa.

aproveitando o código criado pelo Eclipse, chamaremos o super, ou seja, subiremos na hierarquia
para chamarmos o método saca da classe Conta, a unica alteração será no vaor, que passará a ser 
valorASacar:


public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
}




no método transfere localizado na classe mãe Conta, quando utilizamos o this.saca, estamos chamando o método
saca com o valor, para destino.deposita temos a mesma coisa,  é feita uma referência, o this é uma referência.

public class Conta {

//Código omitido

public boolean transfere(double valor, conta destino) {
    if(this.saca(valor)) {
        destino.deposita(valor);
        return true;
    } else {
        return false;
    }
}

//Código omitido



Na classe TesteContas, quan do utilizamos o cc.transfere, o this tem o mesmo valor de cc, ou seja, o this é a seta
que aponta para um objeto do tipo ContaCorrente. 

Desta forma, estaremos chamando o método mais específico, ou seja, o da ContaCorrentem por isso, 
ao executarmos a classe TesteContasjá obtivemos o resultado esperado.



Aula 07 - Capítulo 04 - O que aprendemos?

Nessa aula, vimos:

 - Conceitos de herança, construtores e polimorfismo
 - A utilização da anotação @Override
 - Construtores não são herdados
 - Um construtor da classe mãe pode ser chamado através do super()




Aula 01 - Capítulo 05 - Classes Abstratas


Utilizando a classe Funcionario novamente, voltaremos ao projeto
bytebank-herdado, que tem as classes Funcionario e Gerente, seguindo hierarquia que tínhamos, onde 
o Funcionario é a super classe.

os filhos desta classe são Gerente, EditorVIdeo e Designer.

em uma empresa de verdade não existe o cargo Funcionario, porém, não podemos apagar simplesmente 
a classe Funcionario, pois, muita coisa pararia de funcionar, pois o conceito comum
de Funcionario é importante para nosso código, para resolver isso
abriremos a classe Funcionario e queremos evitar de alguma forma a existência de um funcionário 
desta forma, sem nenhum cargo específico. Para que isso aconteça, o new Funcionario() não deveria
funcionar, pois, estaríamos criando algo que é só um funcionário.

No exemplo, "funcionário" é um conceito, algo abstrato, o concreto seria, gerente, programador,
designer, editor de vídeo e por ai vai, note que todos são funcionários, mas não apenas isso.

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//codigo omitido
	
}


A palavra abstract sempre estará relacionado com herança

antes no nossa classe TesteReferencias estavamos fazendo um new Funcionario();
isso gerará um erro de compilação, pois, não é mais possível criar um funcionario. 
o new indica criação de algo concreto, como a classe Funcionario agora 
é abstrata, será indicado como erro de compilação.


podemos simplesmente tirar este trecho de código ou então criar um 
Gerente, Designer, EditorVideo... pois todos são realmente funcionarios.


na classe TesteFuncionario, temos tambem:

import java.text.DecimalFormat;

public class TesteFuncionario {
	
	public static void main(String[] args) {
		
		DecimalFormat formatador = new DecimalFormat("0.00");
		
		//Funcionario brunno = new Funcionario(); -> erro de compilação
		Funcionario brunno = new Gerente();
		
		brunno.setNome("Brunno Manduca");
		brunno.setCpf("083540479-03");
		brunno.setSalario(2500.80);
		
		System.out.println("Nome: " + brunno.getNome());
		System.out.println("CPF: " + brunno.getCpf());
		System.out.println("Salário: " + brunno.getSalario());
		System.out.println("Bonificação: " + formatador.format(brunno.getBonificacao()));
		
	}
	
}


ao trocarmos o tipo de funcionario para gerente, o codigo compila certinho, 
Ou seja, assim temos um filho concreto (Gerente), da classe Funcionario.

O mesmo conceito pode ser aplicado à estrutura de contas, temos uma conta
 poupança e outra corrente, mas não existe um tipo que seja simplesmente "conta".


Aula 03 - Capítulo 05 - Métodos abstratos


aprendemos que não é possível instanciar objetos desta classe Funcionario, pois a mesma é abstrata...

//nao pode instanciar essa classe, pq é abstrata
public abstract class Funcionario {

    private String nome;
    private String cpf;
    private double salario;

	//Código omitido
	
}

Desta forma, evitamos que seja instanciado um funcionário genérico, já que a função não existe na prática.

Os códigos das classes filhas continuam funcionando normalmente, graças ao polimorfismo, podemos fazer 
referências genéricas. Não perdemos os benefícios da herança, apenas eliminamos a possibilidade de criar um 
objeto com uma referência do tipo Funcionario, o que não faz sentido.


Agora, o chefe da empresa, decidiu que não deve existir mais uma regra padrão de bonificação para todos. 
o designer receberá R$200,00, o editor de vídeo receberá R$150,00 e o gerente um salário simples.
Não há mais uma regra padrão.

Como temos um parâmetro específico para cada funcionário, não precisamos mais do método 
getBonificacao() na classe Funcionario, por isso, ficará comentado:




public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//utilizando modificador public, para que o método tenha visibilidade pública
	/*public double getBonificacao() {
		return this.salario * 0.1;
	}*/
	
	//codigo omitido

}


Nenhuma das classes filhas utiliza o método getBonoificacao() da classe mãe, cada uma conta com seu 
próprio método específico..

Abriremos a classe ControleBonificacao:

public class ControleBonificacao {

        private double soma;

        public void registra(Funcionario f) {
            double boni = f.getBonificacao();
            this.soma = this.soma + boni;
        }

        public double getSoma() {
            return soma;
        }
}

 
E temos um problema, porque a classe Funcionario não tem mais o método getBonificacao(), 
e está apontando para um objeto f, do tipo Funcionario() - isso significa que o código não compilará.

Se apontasse para um objeto g, por exemplo, isso não aconteceria pois, na classe Gerente, 
há um método getBonificacao específico.

Ou seja, comentar o método em Funcionario não foi uma boa solução. 
Removeremos as barras para retorná-lo à forma
 

Temos que garantir que este método exista para as classes filhas. Ele precisa existir, para que o 
ControleBonificacao funcione. Entretanto, o ideal seria que ele não tivesse uma implementação, 
ou seja, que existisse da seguinte forma:

public abstract class Funcionario {

	private String nome;
	private String cpf;
	private double salario;
	
	//porém, getBonificacao() é um método concreto e para que isso funcione, declararemos ele como abstrato
	public abstract double getBonificacao();
	
}


Da mesma forma que existem classes bastratas, também existem métodos abstratos.


Na classe, significa que não é possível instanciar objetos desta classe.
No método, significa que ele não tem um corpo, ou seja, 
que não foi implementado.

como solução: O método será implementado somente nas classes filhas.


Ex.:
public class Designer extends Funcionario {

    public double getBonificacao() {
        return 200;
    }
    
}


ao colcoar o método abstrato em uma classe mãe, obrigamos os filhos a implementar 
tal método



mas há algumas outra forma de conseguir compliar esta classe, sem que utilizemos um método abstrato?
Sim, poderíamos implementar um método diretamente na classe filha, ou indicar que a própria classe filha é abstrata.

Sendo assim, aprendemos que abstract é uma palavra-chave que podemos utilizar tanto antes de 
uma classe quanto antes de um método. Apesar de seu significado estar relacionado, ele é diferente da herança.



Aula 07 - Capítulo 05 - Abstract no exemplo Conta


Falando do ponto de vista prático, não deve existir um tipo de objeto que seja somente uma conta, 
ele deve ser ou corrente ou poupança, mas não queremos apagar a classe Conta, pois, 
precisamos de seus atributos e métodos.

Para isso, manteremos esta classe, na forma abstrata.

public abstract class Conta {
	
	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido

}


assim, não será possível instanciar objetos da classe Conta;

Para ilustrar, abriremos a classe TesteContas e ao tentarmos criar um objeto do tipo Conta(), 
veremos que não é possível compilar este código.


Uma classe abstrata, pode sim ter atributos e eles serão herdados pelas classes filhas.
Ela pode sim ter construtores também, pois estes construtores não são herdados automaticamente
ou diretamente, mas podem ser chamados em classes filhas por da palavra reservada super. A classe
abstrata pode sim ter métodos também e os filhos herdam estas funcionalidades.

tudo continua de alguma forma válido, a unica vedação seria o instanciamento de objetos 
do tipo da classe abstrata. 



para praticar nos métodos, utilizaremos abstract no método deposita:

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor) {
		
		this.saldo = this.saldo + valor;
		
	}

}


assim que colocamos o abstract, gera um erro, pois não podemos colocar a classe como abstract
e manter a implementação toda ali.

Isso pode ser resolvido de duas formas:
 - tirando o abstract
 - removendo toda a implementação;
 

public abstract class Conta {

	private double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//código omitido
	
	public abstract void deposita(double valor);

}



Agora as classe filhas serão obrigadas a implementar este método.



Class ContaCorrente:

public class ContaCorrente extends Conta {
	
	public ContaCorrente(int agencia, int numero){
		super(agencia, numero);
	}
	
	@Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		return super.saca(valorASacar);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


após implementar o deposita, 
acessaremos o saldo, com o super, entretanto, ele não é visível, pois tem um modificador de visibilidade privado.
Podemos alterá-lo para protected, liberando assim o atributo para os filhos.

public abstract class Conta {

	protected double saldo;
	private int agencia;
	private int numero;
	private Cliente titular;
	private static int total = 0;
	
	//codigo omitido
	
}



fazendo o mesmo para a ContaPoupanca:


public class ContaPoupanca extends Conta {
	
	public ContaPoupanca(int agencia, int numero) {
		super(agencia, numero);
	}
	
	@Override
	public void deposita(double valor) {
		super.saldo += valor;
	}

}


Nessa aula aprendemos:

 - O que são classes abstratas
 - Para que servem classes abstratas
 - O que são métodos abstratos
 - Para que servem métodos abstratos


Aula 01 - Capítulo 06 - Mais uma classe abstrata


Revisando: 

temos a hierarquia: A classe mãe é Funcionario e as filhas são 
Gerente, EditorVIdeo e Designer.

A classe mãe é abstrata, enquanto as filhas são todas concretas. Lembrando também que a classe Gerente 
tem um método autentica(), que é do tipo boolean.

Cirando uma nova classe chamada SistemaInterno. Justamente, surgiu esta necessidade, de representarmos 
um sistema interno da empresa, que não é acessível para todos:


public class SistemaInterno {

}


Atenção, este sistema será visualizado por alguns funcionários, por isso, conterá um  método autentica() próprio, que recebe como paramêtro
um Gerente g, como base nisso o método será chamado e a senha será definida em um atributo, acima do método.
Consequentemente, esta senha será passada para o método autentica():


public class SistemaInterno {

		private int senha = 2222;

        public void autentica(Gerente g) {
            g.autentica(senha);
        }
        
}


como o metodo devolve true ou false, por isso, ele será do tipo boolean. 
Se caso autenticar, impriremos uma mensagem "Pode entrar no sistema!!", 
casp contrário, a mensagem "Senha incorreta! Não pode entrar no sistema!" será exibida.


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}



Criando agora um teste para a classe, chamada TesteSistema, 
criando um novo gerente, e o daremos uma senha. Além disso, instituiremos 
um sistema interno, passando o gerente g:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);	
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);

	}

}


Criando  um novo tipo de funcionario, para isso teremos a classe Administrador e cuja super classe será Funcionario:


public class Administrador extends FuncionarioAutenticavel {
	
	
	@Override
	public double getBonificacao() {
		return 50;
	}
	
	

}


Porém, o Administrador também terá uma senha e consequentemente, deverá ter também um método autentica, 
mas este código causará estranheza, pois estará repetindo linhas e também não resolverá o problema. 
Na classe TesteSistema, tentaremos criar um administrador, com uma senha e autenticar o mesmo:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);

	}

}

ao passamors a linha si.autentica(adm), teremos um erro de compilação, isso acontece porque na classe 
SistemaInterno só é aceito o Gerente, ou seja, teríamos que duplicar o método autentica na classe SistemaInterno, 
porém, essa constante repetição de código não é uma boa prática de programação, então deixaremos o código como está 
hoje, sem o método autentica(Administrador adm)


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(Gerente g) {
		
		boolean autenticou = g.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


Em vez de duplicar, poderíamos inseri-lo na classe mãe Funcionario, 
o problema desta abordagem é que agora, tanto o EditorVideo e o Designer podem entrar no 
SistemaInterno, algo que não poderia acontecer..


A ídeia então é tirar o método autentica() da classe Funcionario, porque ela não se aplica a todos os funcionarios.
para solucionar este caso, teremos uma nova classe, intermediária entre a classe mãe Funcionario e as filhas autenticaveis
Administrador e Gerente.

A nova classe se chamará FuncionarioAutenticavel e as classe Administrador e Gerente estenderão esta classe.
A classe FuncionarioAutenticavel, por sua vez, estenderá a classe Funcionario.

A classe FuncionarioAutenticavel será abstrata e o método autentica() será armazenado, portanto, nessa classe.

Criando a classe FuncionarioAutenticavel e inserimos nela o método autentica():


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}



Agora, como próximo passo, temos que adequar as classes Gerente e Administrador, para estender da classe FuncionarioAutenticavel


Agora sim, as classes atendem a nossa hierarquia.
SistemaIterno ficará assim:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}

E o TesteSistema:


public class SistemaInterno {
	
	private int senha = 2222;
	
	public void autentica(FuncionarioAutenticavel fa) {
		
		boolean autenticou = fa.autentica(this.senha);
		
		if (autenticou) {
			System.out.println("Pode entrar no sistema!!");
		} else {
			System.out.println("Senha incorreta! Não pode entrar no sistema!");
		}
		
	}
	
	
}


assim, o código funcionará normalmente, sem necessidade de duplicar o código.





Aula 02 - Capítulo 06 - Herança multipla


O SistemaInterno não depende diretamente do Administrador nem do Gerente. 
A Abstração entre os tipos específicos de funcionários e a classe SistemaInterno é a classe autenticavel. 
Esta é a vantagem, pensando sob a ótica de design.

Criando um novo tipo de funcionário autenticavel, como por exemplo, um diretor, com uma classe Diretor, 
que estenede a classe FuncionarioAutenticavel, ou seja, podemos fazer isso sem alterar o código da classe SistemaInterno, 
nem da FuncionarioAutenticavel. Esta é a grande vantagem. Os dois lados podem evoluir separadamente.

Desde que não haja uma separação na classe FuncionarioAutenticavel, as suas classes filhas não serão afetadas. 
Esta é a vantagem do design desta abstração, do polimorfismo.

Nosso novo desafio é que não basta mais representarmos apenas funcionários em nossos sistemas, teremos que representar
também os clientes.

A classe Cliente também terá acesso ao SistemaInterno, além disso, ela também será autenticável.

o que poderíamos fazer inicialmente, é que a classe Cliente estendesse a classe FuncionarioAutenticavel, porém, 
de cara não parece ser uma boa idéia.

Criando a classe Cliente, estendendo a classe FuncionarioAutenticavel:


public abstract class FuncionarioAutenticavel extends Funcionario {
	
	@Override
	public double getBonificacao() {
		return 0;
	}

}


Já pode se perceber um primeiro problema, pois, faz sentido o Cliente receber uma bonificação?
Pois, ele não é um funcionário, além disso, na hierarquia, esta da seguinte forma:
O cliente é um funcionário autenticável e também um funcionário.


A primeira parte da afirmação já nos soa bem estranho, porque apesar de ter a autenticação, cliente não
é um funcionário. 
Piora, quando subimos na hirerarquia e vemos que não é possível afirmarmos que o clienteé um funcionario.
Ser um funcionario, significa receber uma bonificação.

Exemplificando, criando um objeto Cliente, 

poderíamos também, ter no lado esquerdo, a classe FuncionarioAutenticavel, graça ao polimorfismo...

public class TesteFuncionario {

        public static void main(String[] args) {

        //Cliente cliente = new Cliente();
        //FuncionarioAutenticavel cliente = new Cliente();
        Funcionario cliente = new Cliente();

        //Código omitido
        
}


Isso, acaba soando estranho, pois cliente seria um funcionario ao mesmo tempo, além disso, 
seria aberta a possibilidade de definirmos um salário para o cliente, algo que também não faria sentido.

Desta forma, a classe Cliente poderia chamar métodos que não deveria ou não poderia ter permissão.

o problema ate aqui, é que o Cliente se torna um funcionario, não é muito eficiente.

Ao observar a classe FuncionarioAutenticavel percebemos que ela, na verdade tem relação somente com a 
senha e o método autentica() e não necessariamente com os funcionários, por isso, ela será renomeada
para somente Autenticavel.


Apesar dessa alteração, como não alteramos a hierarquia, o Cliente continua sendo um Funcionario, já 
que a classe Autenticavel estende Funcionario. Precisamos retirar essa relação.

Assim, retiraremos o extends

public abstract class Autenticavel {
	
	private int senha;
	
	public void setSenha(int senha) {
		this.senha = senha;
	}
	
	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}

ao salvar, começará a apontar vários erros em diversas classes

Em Gerente, temos um problema pois não estamos mais estendendo diretamente a classe Funcionario, por isso, 
não temos mais um getSalario.

Para o Administrador temos um erro similar, não é possível sobrescrever o método getBonificacao(), já que deixamos de herdá-lo

sendo assim, resolvemos o problema do Cliente, mas acabamos criando novos problemas.


No entanto, os métodos setNome(), setCpf() e setSalario(), todos deixaram de funcionar, porque agora o Gerente e 
o Administrador não herdam mais Funcionário.


A herança múltipla não funciona no mundo Java, por isso não adianta querer estender duas classes.
A herança múltipla não é utilizada no Java, porque poderia gerar confusão, Imaginemos que a classe Funcionario
tem uma senha e um método setSenha(), como saberemos que Autenticavel possui exatamente isto. 
Se o Gerente estender ambas, qual dos dois prevalece? Para evitar este tipo de problema, no Java, 
não há herança múltipla.



public class Gerente extends Funcionario{
	
	//codigo omitido

}

o mesmo caso, para o administrador:

public class Administrador extends Funcionario{
	
	//codigo omitido

}



dentro da classe TesteGerente, deixaremos as linhas de código referentes ao 
método autentica() comentado. 


public class TesteGerente {

	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("05446985236");
		g1.setSalario(5000.00);
		
		
		/*g1.setSenha(2222);
		boolean autenticou = g1.autentica(2222);*/
		
		System.out.println("Nome " + g1.getNome());
		System.out.println("CPF: " + g1.getCpf());
		System.out.println("Salário: " + g1.getSalario());
		System.out.println("Bonificação: " + g1.getBonificacao());
		/*System.out.println(autenticou);*/

	}

}




Na classe TesteSistema, também há vários erros, pois, agora Gerente não pode acessar o SistemaInterno. 
Por enquanto comentaremos as seguintes linhas de código:



public class TesteSistema {

	public static void main(String[] args) {
		
		/*Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);*/

	}

}


agora o código está funcionando, mas para isso foi preciso remover a relação 
entre Gerente e a classe Autenticavel e ele voltou a estender a classe Funcionario, o mesmo
foi feito com o Administrador.



Aula 03 - Capítulo 06 - A primeira interface


O Objetivo agora é que as três classes: Cliente, administrador e Gerente consigam acessar o SistemaInterno, considerando 
que apenas o Administrador e o Gerente são funcionários e herdam Funcionario

Buscaremos estabelecer algum tipo de relacionamento entre a classe Gerente e a Autenticavel, que não poderá ser herança, 
já que não é possível que o gerente estenda duas classes ao mesmo tempo (Herança múltipla), esta outra relação se chama interface.

De ínicio, precisaremos transformar a classe Autenticavel em uma interface, que é uma classe Abstrata, com todos os métodos 
abstratos. Dentro de uma interface, não ha nada concreto.

A classe Autenticavel tem vários atributos, porém, como ela se tornará uma classe abstrata, não pode ter implementação, 
sendo assim, ela ficará da seguinte forma:


public abstract class Autenticavel {
	
	public abstract void setSenha(int senha);
	
	
	public abstract boolean autentica(int senha);

}

Em outras palavras, eliminamos da classe, tudo que era concreto, mantivemos apenas a assinatura dos métodos.
Agora transformaremos ela em uma interface.

ao trocarmos o valor class por interface:

public abstract interface Autenticavel {
	
	public abstract void setSenha(int senha);
	
	
	public abstract boolean autentica(int senha);

}



Para colocar em prática essa alteração e verificarmos seu funcionamento, na classe Cliente, 
vemos que ela já apresenta um erro de compilação, na maneira que ela se encontra hoje, pois 
estamos utilizando a referência extends:

public class Cliente extends Autenticavel {

}

O extends existe somente para quando teremos que herdar algo de outra classe, 
mas com a interface, estamos "assinando um contrato", ou seja, estamos implementando, 
por isso, utilizamos o implements e agora gerando os métodos concretos, so efetuar a implementação que tinhamos 
antes aqui:


public class Cliente implements Autenticavel {
	
	private int senha;

	@Override
	public void setSenha(int senha) {
		this.senha = senha;
	}

	@Override
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

}


Desta forma, obrigamos o Cliente a ter uma senha e um método Autentica. 
Quem for Autenticavel, deverá implementar estes métodos.


E assim, repetiremos o mesmo processo para Administrador e Gerente, ambos estão conectados à 
interface por uma seta pontilhada, indicando que ambos também "assinam o contrato" Autenticavel.

Ao passo em que só é possível fazer com que uma classe herde apenas uma outra classe, podemos fazer com que sejam 
"assinados" tantos "contratos" forem necessários, ou seja, não há limite para o número de implementações.


Aula 05 - Capítulo 06 - Completando o sistema


Inicialmente criamos a interface Autenticavel e o Cliente já a implementou, 
precisamos agora implementar no Administrador e no Gerente..

abrindo a classe Gerente:

public class Gerente extends Funcionario implements Autenticavel {

        public double getBonificacao() {
                return super.getSalario();
        }
}


Automaticamente, após criar e implementar Autenticavel, a classe Gerente se obriga
a implementar os métodos da interface, ou seja, setSenha e autentica.. ela ficará assim:

public class Gerente extends Funcionario implements Autenticavel {

        private int senha;

        public double getBonificacao() {
                System.out.println("Chamando o método de bonificacao do GERENTE");
                return super.getSalario();
        }

        @Override
        public void setSenha(int senha) {
            this.senha = senha;
        }

        @Override
        public boolean autentica(int senha) {
            if(this.senha == senha) {
                return true;
            } else {
                return false;
            }
        }
}


Em outras palavras, a classe Gerente é um Funcionário, herda da classe Funcionario, assina o contrato
Autenticavel e é um Autenticavel.


É possivel colocar mais de uma interface, pois não é que nem herança, que so existe no JAVA a simples.
Isso porque, como nesta modalidade não há nada concreto, não corremos o o risco de acontecer uma duplicidade 
de métodos, a implementação acontecerá na própria classe, evitando assim qualquer confusão.


Mesma aplicação, para o administrador:

public class Administrador extends Funcionario implements Autenticavel {

        private int senha;

        @Override
        public double getBonificacao() {
                return 50;
        }

        @Override
        public void setSenha(int senha) {
            this.senha = senha;
        }

        @Override
        public boolean autentica(int senha) {
            if(this.senha == senha) {
                return true;
            } else {
                return false;
            }
        }
}

Somente recapitulando:
 - Gerente é um Funcionario e assina Autenticavel;
 - Administrador é Funcionario e assina Autenticavel; 
 - Cliente é Autenticavel;


No SistemaInterno:

public class SistemaInterno {

        private int senha = 2222;

        public void autentica(Autenticavel fa) {

        //Código omitido
        
}

Percebemos que a conexão entre a classe e a Autenticavel continua existindo. Esta é a vantagem de termos uma interface, podemos utiliza-lá 
para definir um tipo

Abrindo a classe TesteGerente:


public class TesteGerente {

	public static void main(String[] args) {
		
		Gerente g1 = new Gerente();
		g1.setNome("Rafael");
		g1.setCpf("05446985236");
		g1.setSalario(5000.00);
		
		
		g1.setSenha(2222);
		boolean autenticou = g1.autentica(2222);
		
		System.out.println("Nome " + g1.getNome());
		System.out.println("CPF: " + g1.getCpf());
		System.out.println("Salário: " + g1.getSalario());
		System.out.println("Bonificação: " + g1.getBonificacao());
		System.out.println(autenticou);

	}

}

Podmeos descomentar o trecho com método getSenha(), pois, o mesmo
volta a funciona, porque agora o Gerente sabe setar a senha e sabe se autenticar.


Na classe TesteSistema, estava com todo o código comentado, podemos desfazer a ação, 
pois, tudo estará funcionando:


public class TesteSistema {

	public static void main(String[] args) {
		
		Gerente g = new Gerente();
		g.setSenha(2222);
		
		Administrador adm = new Administrador();
		adm.setSenha(3333);
		
		Cliente clt = new Cliente();
		clt.setSenha(5678);
		
		
		SistemaInterno si = new SistemaInterno();
		System.out.println("Senha do Gerente: ");
		si.autentica(g);
		System.out.println();
		System.out.println("Senha do Administrador: ");
		si.autentica(adm);
		System.out.println();
		System.out.println("Senha do Cliente: ");
		si.autentica(clt);

	}

}


Desta forma, o Gerente continua sendo um Funcionario, o Cliente não é, mas os dois 
são capazes de acessar o mesmo SistemaInterno. Isso acontece porque a interface é absolutamente genérica

todos os tipos de funcionarios, Administrador, Gerente, EditorVideo e Designer, estendem da classe Funcionario.

A interface Autenticavel, por sua vez, é a abstração entre SistemaInterno e todas as pessoas que desejam acessa-lo.
Ainda que as pessoas não tenham relação entre si.



Nessa aula aprendemos que:

 - Não existe herança múltipla em Java.
 - Conceitos de interface.
 - Diferenças entre classes abstratas e interfaces.
 - interfaces são uma alternativa a herança referente ao polimorfismo




Aula 01 - Capítulo 07 - Revendo a composição


Anterioremente, definimos nossa própria interface e como vimos, ela não possui um código concreto.
Não é possível definir um atributo dentro de uma, o código simplesmente não compila. Da mesma forma, 
nenhum método podera ter uma implementação.

Uma Interface só define métodos, as regras destes devem ser definidas nas classes que a implementam.

No caso da interface Autenticavel:


public abstract interface Autenticavel {
	
	public abstract void setSenha(int senha);
	
	
	public abstract boolean autentica(int senha);

}


Todas as classes que a implementarem terão a obrigação de implementar os métodos setSenha() e autentica()


Em comparação com o conceito de herança, onde temos os pilares da reutilização de código e o polimorfismo, quando falamos
de interfaces, não há código concreto, assim, o objetivo não é a reutilização de código, ela é, sim uma alternativa ao polimorfismo.

Solução pura de polimorfismo -> utilizar interface

Mas e se quisermos somente reutilização de código, é recomendado utilizar a herança?
Não, a herança é recomendada quando há a combinação das necessidades de reutilização de código e polimorfismo.

e se a necessidadefor somente a reutilização de código?

anteriormente, podemos perceber que repetimos várias vezes, as linhas de código
referente aos métodos setSenha() e autentica(). 
A idéia é isalar estar linhas de código em uma classe.


Criaremos então a classe Autenticador e incluiremos nesta nova classe
os métodos setSenha() e autentica():


public class Autenticador {
	
	private int senha;
	
	
	public void setSenha(int senha) {
		this.senha = senha;
	}

	
	public boolean autentica(int senha) {
		
		if (this.senha == senha) {
			return true;
		} else {
			return false;
		}
		
	}

	
}


agora, não podemos simplesmente apagar estes métodos das outras classes, 
pois isso resultaria na quebra de compromisso com a interface Autenticavel. 
Manteremos a assinatura e eliminaremos a lógica dos métodos.

primeiramente acessamos a classe Cliente e para resolver este problema, 
teremos um atributo Autenticador e criaremos um construtor padrão para, 
dentro dele, teremos uma instância do Autenticador. 

Com isso, eliminamos a necessidade da existência do atributo 
senha, desta forma, quando chamar a senha, quem guardará essa 
informação não será diretamente a própria classe e sim o Autenticador. 
No autenticador, chamaremos o autenticador, desta forma, utilizamos o seu setSenha. Isso significa que 
delegamos a chamada - o método não foi embora, mas a implementação, que era concreta, agpra foi delegada..



public class Cliente implements Autenticavel {
	
	private Autenticador autenticador;
	
	//constructor
	public Cliente() {
		this.autenticador = new Autenticador();
	}

	@Override
	public void setSenha(int senha) {
		this.autenticador.setSenha(senha);
	}

	@Override
	public boolean autentica(int senha) {
		return this.autenticador.autentica(senha);
	}

}


agora aplicando todo esse processo novamente no Administrador:


public class Administrador extends Funcionario implements Autenticavel{
	
	private Autenticador autenticador;
	
	//constructor
	public Administrador() {
		this.autenticador = new Autenticador();
	}
	
	@Override
	public double getBonificacao() {
		return 50;
	}
	
	@Override
	public void setSenha(int senha) {
		this.autenticador.setSenha(senha);
	}

	@Override
	public boolean autentica(int senha) {
		return this.autenticador.autentica(senha);
	}

}


e agora na classe Gerente:

public class Gerente extends Funcionario implements Autenticavel{
	
	private Autenticador autenticador;

	public double getBonificacao() {
		return super.getSalario();
	}


	//constructor
	public Gerente() {
		this.autenticador = new Autenticador();
	}
	
	
	@Override
	public void setSenha(int senha) {
		this.autenticador.setSenha(senha);
	}

	@Override
	public boolean autentica(int senha) {
		return this.autenticador.autentica(senha);
	}


}



Recapitulando:

 - Criamos uma nova classe, Chamada Autenticador
 - As classes Cliente, Administrador e Gerente as utilizam, esse relacionamento se chama de composição;
 
 O relacionamento de composição difere do relacionamento de herança, naquele, há ainda uma interdependência 
 onde a existência de um depende da do outro, já na composição, cada classe existe independentemente.
 
 Isso significa, que quando queremos fazer apenas a reutilização de código, podemos utilizar composição. 
 teoricamente, podemos trablhar sem herança com o Java.
 
 

No fim, temos as duas opções em Java. Atualmente, é mais comum a utilização das interfaces e composições, em 
detrimento da herança, mas é importante sabermos que ambos existem.



Aula 02 - Capítulo 07 - Mais uma interface

A hierarquia está estruturada da seguinte forma: 

A classe Conta é a mãe, e é abstrata, por sua vez, as classes
ContaCorrente e Conta Poupanca a herdam

O objetivo em si é incluir um calculador de imposto, representado pela 
classe CalculadorImposto. 
Uma contacorrente é tributável, enquanto que uma conta poupanca não é.

Além disso, teremos um seguro de vida, representado pela Classe SeguroDeVida, que não herda a classe Conta, 
mas também é tributado e acordo com o CalculadorImposto.

Para que o CalculadorImposto não fique atrelado a nenhum método específico, teremos um intermedíario, 
que será uma interface, chamada Tributavel.

Recapitulando: Uma interface contém somente abstrações, não possui nenhum atributo ou método concreto.

O CalculadorImposto, por usa vez, trabalhará com esta interface Tributavel. As classes SeguroDeVida e ContaCorrente
deverão implementar a interface Tributavel.

A idéia do CalculadorImposto é que ele armazena o valor dos impostos, somando todos os valores.






















